function getYAxisMax(value) {
  if (value <= 0) return 0;

  const pow10 = Math.pow(10, Math.floor(Math.log10(value)));
  // 0.1 ~ 10까지 다양한 배율 (5~9 구간 맞추기 위함)
  const factors = [0.1, 0.2, 0.3, 0.5, 1, 2, 3, 5, 10];

  let bestAxisMax = null;
  let bestStep = null;

  for (const f of factors) {
    const step = f * pow10;
    if (step <= 0) continue;

    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step;

    // 조건: 5~9 구간
    if (ticks >= 5 && ticks <= 9) {
      // 항상 더 "거친" step(큰 step)을 우선 선택
      if (bestAxisMax === null || step > bestStep ||
         (step === bestStep && axisMax < bestAxisMax)) {
        bestAxisMax = axisMax;
        bestStep = step;
      }
    }
  }

  // 후보가 없으면 안전망 (10배수로 올림)
  if (bestAxisMax == null) {
    const step = 10 * pow10;
    return Math.ceil(value / step) * step;
  }
  return bestAxisMax;
}


ㅡㅡㅡㅡㅡㅡ

동일 결과 다른 코드



// raw 이상이 되는 "다음 예쁜 step": 베이스 1,2,3,5 × 10^k
function nextNiceStep(raw) {
  if (!(raw > 0)) return 1;
  const k = Math.floor(Math.log10(raw));
  const p = Math.pow(10, k);
  const base = raw / p;
  if (base <= 1) return 1 * p;
  if (base <= 2) return 2 * p;
  if (base <= 3) return 3 * p;
  if (base <= 5) return 5 * p;
  return 10 * p;
}

// 항상 "coarse" 규칙: 5~9 구간 중 더 큰 step을 우선
function getYAxisMax(value) {
  if (value <= 0) return 0;

  let bestMax = null;
  let bestStep = 0;

  for (let seg = 5; seg <= 9; seg++) {
    const step = nextNiceStep(value / seg);
    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step;

    if (ticks >= 5 && ticks <= 9) {
      if (step > bestStep || (step === bestStep && (bestMax === null || axisMax < bestMax))) {
        bestStep = step;
        bestMax = axisMax;
      }
    }
  }

  // 안전망: 혹시라도 후보가 없으면, 5구간 기준으로 한 번 더 올림
  if (bestMax == null) {
    const step = nextNiceStep(value / 5);
    return Math.ceil(value / step) * step;
  }
  return bestMax;
}



ㅡㅡㅡㅡㅡㅡ
최종 간단 버전


// y축 최대값 계산 (항상 5~9 ticks 중 "구간 수가 적은" 해를 우선)
// 전제: value는 정수 ≥ 1, 소수 없음. (≤0이면 0 반환)
function getYAxisMax(value) {
  if (value <= 0) return 0;

  const pow10 = Math.pow(10, Math.floor(Math.log10(value)));

  const factors = [0.1, 0.2, 0.3, 0.5, 1, 2, 3, 5,  10];

  let bestAxisMax = null;
  let bestStep = 0;

  for (const f of factors) {
    const step = f * pow10;
    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step; // 정수

    if (ticks >= 5 && ticks <= 9) {
      // "큰 step(=더 적은 구간)" 우선, 동률이면 axisMax가 작은 쪽
      if (step > bestStep || (step === bestStep && (bestAxisMax === null || axisMax < bestAxisMax))) {
        bestStep = step;
        bestAxisMax = axisMax;
      }
    }
  }
  return bestAxisMax;
}



ㅡㅡㅡㅡㅡㅡ
최대값이 작은 것이 우선

function getYAxisMax(value) {
  if (value <= 0) return 0;

  // 소수점 올림 처리
  value = Math.ceil(value);

  const pow10 = Math.pow(10, Math.floor(Math.log10(value)));
  const factors = [0.1, 0.2, 0.3, 0.5, 1, 2, 3, 5, 10];

  let bestAxisMax = null;
  let bestStep = null;

  for (const f of factors) {
    const step = f * pow10;
    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step;

    if (ticks >= 5 && ticks <= 9) {
      // 조건 충족 시: axisMax가 더 작은 쪽을 우선 선택
      if (bestAxisMax === null || axisMax < bestAxisMax ||
         (axisMax === bestAxisMax && step > bestStep)) {
        bestAxisMax = axisMax;
        bestStep = step;
      }
    }
  }
  return bestAxisMax;
}


ㅡㅡㅡㅡㅡ

// 데이터 값으로부터 적절한 축 눈금 간격(interval) 계산
function calcAxisInterval(rough) {
  if (rough <= 0) return 1;

  const exponent = Math.floor(Math.log10(rough)); // 자리수 지수
  const scale = Math.pow(10, exponent);           // 자리수 기준값
  const normalized = rough / scale;               // 1 <= normalized < 10

  const base =
    normalized <= 1.5 ? 1 :
    normalized <= 2.5 ? 2 :
    normalized <= 4.0 ? 3 :
    normalized <= 7.5 ? 5 : 10;

  return base * scale;
}

// 주어진 최대값 기준으로 y축 최대값 계산 (5~9 ticks)
function getYAxisMax(value, splitNumber = 5) {
  if (value <= 0) return 0;
  if (!Number.isInteger(value)) value = Math.ceil(value);

  const step = calcAxisInterval(value / splitNumber);
  return Math.ceil(value / step) * step;
}

ㅡㅡ

위 코드에서 min 받는 코드

// 데이터 값으로부터 적절한 축 눈금 간격(interval) 계산
function calcAxisInterval(rough) {
  if (rough <= 0) return 1;

  const exponent = Math.floor(Math.log10(rough)); // 자리수 지수
  const scale = Math.pow(10, exponent);           // 자리수 기준값
  const normalized = rough / scale;               // 1 <= normalized < 10

  const base =
    normalized <= 1.5 ? 1 :
    normalized <= 2.5 ? 2 :
    normalized <= 4.0 ? 3 :
    normalized <= 7.5 ? 5 : 10;

  return base * scale;
}

// y축 최대값 계산 (min을 외부에서 직접 받음, nice-min 계산 없음)
function getYAxisMax(value, min = 0, splitNumber = 5) {
  if (value <= min) return min;
  if (!Number.isInteger(value)) value = Math.ceil(value);

  const span = value - min;
  const step = calcAxisInterval(span / splitNumber);
  return Math.ceil(value / step) * step;
}


ㅡㅡㅡ
노말라이즈 코드 변경


const thresholds = [1.5, 2.5, 4, 7.5];
const bases      = [1, 2, 3, 5];
const idx = thresholds.findIndex(t => normalized <= t);
// normalized 값이 1.5 이하 → 1, 2.5 이하 → 2, 4 이하 → 3, 7.5 이하 → 5, 그 외는 10
const base = idx === -1 ? 10 : bases[idx];