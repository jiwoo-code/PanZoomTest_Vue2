function getYAxisMax(value) {
  if (value <= 0) return 0;

  const pow10 = Math.pow(10, Math.floor(Math.log10(value)));
  // 0.1 ~ 10까지 다양한 배율 (5~9 구간 맞추기 위함)
  const factors = [0.1, 0.2, 0.3, 0.5, 1, 2, 3, 5, 10];

  let bestAxisMax = null;
  let bestStep = null;

  for (const f of factors) {
    const step = f * pow10;
    if (step <= 0) continue;

    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step;

    // 조건: 5~9 구간
    if (ticks >= 5 && ticks <= 9) {
      // 항상 더 "거친" step(큰 step)을 우선 선택
      if (bestAxisMax === null || step > bestStep ||
         (step === bestStep && axisMax < bestAxisMax)) {
        bestAxisMax = axisMax;
        bestStep = step;
      }
    }
  }

  // 후보가 없으면 안전망 (10배수로 올림)
  if (bestAxisMax == null) {
    const step = 10 * pow10;
    return Math.ceil(value / step) * step;
  }
  return bestAxisMax;
}


ㅡㅡㅡㅡㅡㅡ

동일 결과 다른 코드



// raw 이상이 되는 "다음 예쁜 step": 베이스 1,2,3,5 × 10^k
function nextNiceStep(raw) {
  if (!(raw > 0)) return 1;
  const k = Math.floor(Math.log10(raw));
  const p = Math.pow(10, k);
  const base = raw / p;
  if (base <= 1) return 1 * p;
  if (base <= 2) return 2 * p;
  if (base <= 3) return 3 * p;
  if (base <= 5) return 5 * p;
  return 10 * p;
}

// 항상 "coarse" 규칙: 5~9 구간 중 더 큰 step을 우선
function getYAxisMax(value) {
  if (value <= 0) return 0;

  let bestMax = null;
  let bestStep = 0;

  for (let seg = 5; seg <= 9; seg++) {
    const step = nextNiceStep(value / seg);
    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step;

    if (ticks >= 5 && ticks <= 9) {
      if (step > bestStep || (step === bestStep && (bestMax === null || axisMax < bestMax))) {
        bestStep = step;
        bestMax = axisMax;
      }
    }
  }

  // 안전망: 혹시라도 후보가 없으면, 5구간 기준으로 한 번 더 올림
  if (bestMax == null) {
    const step = nextNiceStep(value / 5);
    return Math.ceil(value / step) * step;
  }
  return bestMax;
}



ㅡㅡㅡㅡㅡㅡ
최종 간단 버전


// y축 최대값 계산 (항상 5~9 ticks 중 "구간 수가 적은" 해를 우선)
// 전제: value는 정수 ≥ 1, 소수 없음. (≤0이면 0 반환)
function getYAxisMax(value) {
  if (value <= 0) return 0;

  const pow10 = Math.pow(10, Math.floor(Math.log10(value)));

  const factors = [0.1, 0.2, 0.3, 0.5, 1, 2, 3, 5,  10];

  let bestAxisMax = null;
  let bestStep = 0;

  for (const f of factors) {
    const step = f * pow10;
    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step; // 정수

    if (ticks >= 5 && ticks <= 9) {
      // "큰 step(=더 적은 구간)" 우선, 동률이면 axisMax가 작은 쪽
      if (step > bestStep || (step === bestStep && (bestAxisMax === null || axisMax < bestAxisMax))) {
        bestStep = step;
        bestAxisMax = axisMax;
      }
    }
  }
  return bestAxisMax;
}



ㅡㅡㅡㅡㅡㅡ
최대값이 작은 것이 우선

function getYAxisMax(value) {
  if (value <= 0) return 0;

  // 소수점 올림 처리
  value = Math.ceil(value);

  const pow10 = Math.pow(10, Math.floor(Math.log10(value)));
  const factors = [0.1, 0.2, 0.3, 0.5, 1, 2, 3, 5, 10];

  let bestAxisMax = null;
  let bestStep = null;

  for (const f of factors) {
    const step = f * pow10;
    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step;

    if (ticks >= 5 && ticks <= 9) {
      // 조건 충족 시: axisMax가 더 작은 쪽을 우선 선택
      if (bestAxisMax === null || axisMax < bestAxisMax ||
         (axisMax === bestAxisMax && step > bestStep)) {
        bestAxisMax = axisMax;
        bestStep = step;
      }
    }
  }
  return bestAxisMax;
}


ㅡㅡㅡㅡㅡ
이차트 비슷하게

// 1–2–5 계열로 rough 이상인 가장 작은 '예쁜 간격'을 선택
function niceStep(rough) {
  if (rough <= 0) return 1;
  const k = Math.floor(Math.log10(rough));
  const p = Math.pow(10, k);
  const x = rough / p;
  const base = x <= 1 ? 1 : x <= 2 ? 2 : x <= 5 ? 5 : 10;
  return base * p;
}

// ECharts 유사: min=0 가정, splitNumber=5(변경 가능)
function autoYAxisMax(dataMax, splitNumber = 5, dataMin = 0) {
  if (dataMax <= 0) return 0;
  // 소수 입력은 그대로 허용(원본 ECharts와 일치). 필요하면 Math.ceil(dataMax) 적용 가능
  const span = dataMax - dataMin;
  const step = niceStep(span / splitNumber);
  const niceMax = Math.ceil(dataMax / step) * step;
  // 필요 시 niceMin도 계산: const niceMin = Math.floor(dataMin / step) * step;
  return niceMax;
}

// 예시
console.log(autoYAxisMax(124.91)); // 140
console.log(autoYAxisMax(44.55));  // 50
console.log(autoYAxisMax(125));    // 150
console.log(autoYAxisMax(672));    // 700