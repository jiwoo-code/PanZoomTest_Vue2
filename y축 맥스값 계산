function getYAxisMax(value) {
  if (value <= 0) return 0;

  const pow10 = Math.pow(10, Math.floor(Math.log10(value)));
  // 0.1 ~ 10까지 다양한 배율 (5~9 구간 맞추기 위함)
  const factors = [0.1, 0.2, 0.3, 0.5, 1, 2, 3, 5, 10];

  let bestAxisMax = null;
  let bestStep = null;

  for (const f of factors) {
    const step = f * pow10;
    if (step <= 0) continue;

    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step;

    // 조건: 5~9 구간
    if (ticks >= 5 && ticks <= 9) {
      // 항상 더 "거친" step(큰 step)을 우선 선택
      if (bestAxisMax === null || step > bestStep ||
         (step === bestStep && axisMax < bestAxisMax)) {
        bestAxisMax = axisMax;
        bestStep = step;
      }
    }
  }

  // 후보가 없으면 안전망 (10배수로 올림)
  if (bestAxisMax == null) {
    const step = 10 * pow10;
    return Math.ceil(value / step) * step;
  }
  return bestAxisMax;
}


ㅡㅡㅡㅡㅡㅡ

동일 결과 다른 코드



// raw 이상이 되는 "다음 예쁜 step": 베이스 1,2,3,5 × 10^k
function nextNiceStep(raw) {
  if (!(raw > 0)) return 1;
  const k = Math.floor(Math.log10(raw));
  const p = Math.pow(10, k);
  const base = raw / p;
  if (base <= 1) return 1 * p;
  if (base <= 2) return 2 * p;
  if (base <= 3) return 3 * p;
  if (base <= 5) return 5 * p;
  return 10 * p;
}

// 항상 "coarse" 규칙: 5~9 구간 중 더 큰 step을 우선
function getYAxisMax(value) {
  if (value <= 0) return 0;

  let bestMax = null;
  let bestStep = 0;

  for (let seg = 5; seg <= 9; seg++) {
    const step = nextNiceStep(value / seg);
    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step;

    if (ticks >= 5 && ticks <= 9) {
      if (step > bestStep || (step === bestStep && (bestMax === null || axisMax < bestMax))) {
        bestStep = step;
        bestMax = axisMax;
      }
    }
  }

  // 안전망: 혹시라도 후보가 없으면, 5구간 기준으로 한 번 더 올림
  if (bestMax == null) {
    const step = nextNiceStep(value / 5);
    return Math.ceil(value / step) * step;
  }
  return bestMax;
}



ㅡㅡㅡㅡㅡㅡ
최종 간단 버전


// y축 최대값 계산 (항상 5~9 ticks 중 "구간 수가 적은" 해를 우선)
// 전제: value는 정수 ≥ 1, 소수 없음. (≤0이면 0 반환)
function getYAxisMax(value) {
  if (value <= 0) return 0;

  const pow10 = Math.pow(10, Math.floor(Math.log10(value)));

  // {1,2,3,5} × 10^(-1,0,1) → [0.1,0.2,0.3,0.5, 1,2,3,5, 10]
  const bases = [1, 2, 3, 5];
  const factors = [];
  for (const exp of [-1, 0, 1]) {
    const p = Math.pow(10, exp);
    for (const b of bases) factors.push(b * p);
  }

  let bestAxisMax = null;
  let bestStep = 0;

  for (const f of factors) {
    const step = f * pow10;
    const axisMax = Math.ceil(value / step) * step;
    const ticks = axisMax / step; // 정수

    if (ticks >= 5 && ticks <= 9) {
      // "큰 step(=더 적은 구간)" 우선, 동률이면 axisMax가 작은 쪽
      if (step > bestStep || (step === bestStep && (bestAxisMax === null || axisMax < bestAxisMax))) {
        bestStep = step;
        bestAxisMax = axisMax;
      }
    }
  }
  return bestAxisMax;
}