import panzoom from 'panzoom';

export default {
  data() {
    return {
      panzoomInstance: null,
      panzoomInitInProgress: false,
    };
  },

  methods: {
    async initPanzoom(refName = 'pzTarget') {
      if (this.panzoomInstance || this.panzoomInitInProgress) {
        console.log('[PZ][STEP0] skip init: already initialized or in progress.');
        return;
      }
      this.panzoomInitInProgress = true;

      // helpers
      const dumpEl = (el) => {
        const inCurrentDoc = !!(el && el.ownerDocument === document);
        const inOwnerBody = !!(el && el.ownerDocument && el.ownerDocument.body && el.ownerDocument.body.contains(el));
        const inCurrentBody = !!(el && document.body && document.body.contains(el));
        const rootNode = el && el.getRootNode ? el.getRootNode() : null;
        return {
          tag: el ? el.tagName : null,
          id: el ? el.id : null,
          className: el ? el.className : null,
          isConnected: !!(el && el.isConnected),
          ownerIsCurrentDocument: inCurrentDoc,
          inOwnerBody: inOwnerBody,
          inCurrentBody: inCurrentBody,
          offsetWidth: el ? el.offsetWidth : null,
          offsetHeight: el ? el.offsetHeight : null,
          rootNodeType: rootNode ? rootNode.constructor.name : null,
        };
      };

      const sameDoc = (el) => el && el.ownerDocument === document;
      const isAttached = (el) =>
        el &&
        (el.isConnected || (el.ownerDocument && el.ownerDocument.body && el.ownerDocument.body.contains(el)));

      const waitUntilReady = (el, timeoutMs) =>
        new Promise((resolve, reject) => {
          function ok() {
            return sameDoc(el) && isAttached(el);
          }
          if (ok()) {
            resolve(true);
            return;
          }

          let mo = null;
          let poll = null;
          let timer = null;

          function cleanup() {
            if (mo) {
              try { mo.disconnect(); } catch (e) {}
              mo = null;
            }
            if (poll) {
              clearInterval(poll);
              poll = null;
            }
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
          }

          try {
            if (typeof MutationObserver !== 'undefined') {
              mo = new MutationObserver(() => {
                if (ok()) {
                  cleanup();
                  resolve(true);
                }
              });
              mo.observe(document.documentElement, { childList: true, subtree: true });
            }
          } catch (e) {
            console.warn('[PZ][WARN2] MutationObserver setup failed:', e && e.message ? e.message : e,);
          }

          poll = setInterval(() => {
            if (ok()) {
              cleanup();
              resolve(true);
            }
          }, 32);

          timer = setTimeout(() => {
            cleanup();
            reject(new Error('PZ_TIMEOUT_NOT_READY'));
          }, timeoutMs);
        });

      // 1) ref → 실제 DOM 확보
      console.log('[PZ][STEP1] resolve ref:', refName);
      let el = this.$refs[refName];
      if (!el) {
        console.error('[PZ][ERR1] ref is null:', refName);
        this.panzoomInitInProgress = false;
        return;
      }
      if (!(el instanceof HTMLElement) && !(el instanceof SVGElement)) {
        if (el.$el && (el.$el instanceof HTMLElement || el.$el instanceof SVGElement)) {
          console.log('[PZ][STEP1a] ref is component → use $el.');
          el = el.$el;
        } else {
          console.error('[PZ][ERR1a] ref is not DOM nor component with $el.');
          this.panzoomInitInProgress = false;
          return;
        }
      }
      console.log('[PZ][DUMP1]', dumpEl(el),);

      // 2) 동일 문서 + 연결 상태 준비 대기
      console.log('[PZ][STEP2] waitUntilReady start...');
      try {
        await waitUntilReady(el, 5000);
      } catch (e) {
        console.warn('[PZ][ERR2] not ready (sameDoc/attached) → abort.', e && e.message ? e.message : e,);
        this.panzoomInitInProgress = false;
        return;
      }
      console.log('[PZ][DUMP2] after waitUntilReady:', dumpEl(el),);

      // 3) 대기 후 ref가 같은지 / 동일 문서인지 재검증
      let cur = this.$refs[refName];
      if (cur && cur.$el) {
        cur = cur.$el;
      }
      if (cur !== el) {
        console.warn('[PZ][ERR3] element replaced during wait → abort.');
        this.panzoomInitInProgress = false;
        return;
      }
      if (!sameDoc(el)) {
        console.warn('[PZ][ERR3a] ownerDocument !== document → must init in that window/iframe context.');
        this.panzoomInitInProgress = false;
        return;
      }

      // 4) 기존 인스턴스 정리
      if (this.panzoomInstance && typeof this.panzoomInstance.dispose === 'function') {
        try {
          console.log('[PZ][STEP4] dispose previous instance.');
          this.panzoomInstance.dispose();
        } catch (e) {
          console.warn('[PZ][WARN4] dispose error:', e && e.message ? e.message : e,);
        }
        this.panzoomInstance = null;
      }

      // 5) panzoom 모듈 형태 확인
      console.log('[PZ][STEP5] typeof panzoom:', typeof panzoom,);

      // 6) 실제 초기화
      try {
        console.log('[PZ][STEP6] about to init on element:', dumpEl(el),);
        const pz = panzoom(el, {
          bounds: true,
          maxZoom: 5,
          minZoom: 0.2,
        });
        if (!pz || typeof pz.zoomTo !== 'function' || typeof pz.dispose !== 'function') {
          console.error('[PZ][ERR6] invalid instance (missing methods).');
          this.panzoomInitInProgress = false;
          return;
        }
        this.panzoomInstance = pz;
        const keys = Object.keys(pz);
        console.log('[PZ][STEP6a] init OK. instance keys:', keys,);
      } catch (e) {
        const msg = e && e.message ? e.message : String(e);
        const stack = e && e.stack ? e.stack : null;
        console.error('[PZ][FAIL6] init error:', msg,);
        if (stack) console.error('[PZ][STACK]', stack,);
        console.log('[PZ][DUMP6] element at fail:', dumpEl(el),);
        this.panzoomInitInProgress = false;
        return;
      }

      // 7) 최종 확인
      console.log('[PZ][STEP7] done. attached:', isAttached(el), 'sameDoc:', sameDoc(el),);
      this.panzoomInitInProgress = false;
    },
  },

  beforeDestroy() {
    if (this.panzoomInstance && typeof this.panzoomInstance.dispose === 'function') {
      try { this.panzoomInstance.dispose(); } catch (e) {}
    }
    this.panzoomInstance = null;
  },
};