function getEligibleNodes(nodes, links, selectedNodeId) {
  // 선택된 노드와 연결된 노드의 ID를 Set으로 저장 (중복 제거 및 빠른 검색 가능)
  const connectedNodeIds = new Set(links
    .filter(link => link.from === selectedNodeId || link.to === selectedNodeId)
    .map(link => (link.from === selectedNodeId ? link.to : link.from))); // 이전 코드와 동일

  // 각 노드의 from 링크 수를 계산하여 객체로 저장
  const fromLinkCounts = links.reduce((counts, link) => {
    counts[link.from] = (counts[link.from] || 0) + 1; // 이전 코드와 동일
    return counts;
  }, {}); // 이전 코드와 동일

  const visited = new Set(); // 순환 방지를 위한 방문 기록

  // 노드 타입별 조건 정의
  const typeConditions = {
    branch: node => (fromLinkCounts[node.id] || 0) <= 1, // branch는 from 링크가 최대 1개
    loss: node => !(fromLinkCounts[node.id] || 0),       // loss는 from 링크가 없어야 함
    leaf: () => true                                     // leaf는 특별한 조건 없음
  }; // 이전 코드와 동일

  return nodes.reduce((eligible, node) => {
    if (
      !connectedNodeIds.has(node.id) && // 이미 연결된 노드 제외 (이전 코드와 동일)
      node.id !== selectedNodeId &&     // 선택된 노드 제외 (이전 코드와 동일)
      !visited.has(node.id) &&          // 순환 방지 조건 추가
      typeConditions[node.type]?.(node) // 타입별 조건 확인 (이전 코드와 동일)
    ) {
      eligible.push(node);              // 조건을 만족하면 결과 배열에 추가 (이전 코드와 동일)
      visited.add(node.id);             // 방문 기록 추가 (순환 방지)
    }
    return eligible;
  }, []);
}




function getEligibleToNodes(nodes, links, selectedNodeId) {
  // 선택된 노드와 연결된 노드의 ID를 Set으로 저장 (중복 제거 및 빠른 검색 가능)
  const connectedNodeIds = new Set(links
    .filter(link => link.from === selectedNodeId || link.to === selectedNodeId)
    .map(link => (link.from === selectedNodeId ? link.to : link.from))); // 이전 코드와 동일

  // 각 노드의 to 링크 수를 계산하여 객체로 저장
  const toLinkCounts = links.reduce((counts, link) => {
    counts[link.to] = (counts[link.to] || 0) + 1; // 이전 코드와 동일
    return counts;
  }, {}); // 이전 코드와 동일

  const visited = new Set(); // 순환 방지를 위한 방문 기록

  // 노드 타입별 조건 정의
  const typeConditions = {
    branch: () => true,                              // branch는 특별한 조건 없음
    loss: node => (toLinkCounts[node.id] || 0) <= 1, // loss는 to 링크가 최대 1개
    leaf: () => false                                // leaf는 연결 불가능
  }; // 이전 코드와 동일

  return nodes.reduce((eligible, node) => {
    if (
      !connectedNodeIds.has(node.id) && // 이미 연결된 노드 제외 (이전 코드와 동일)
      node.id !== selectedNodeId &&     // 선택된 노드 제외 (이전 코드와 동일)
      !visited.has(node.id) &&          // 순환 방지 조건 추가
      typeConditions[node.type]?.(node) // 타입별 조건 확인 (이전 코드와 동일)
    ) {
      eligible.push(node);              // 조건을 만족하면 결과 배열에 추가 (이전 코드와 동일)
      visited.add(node.id);             // 방문 기록 추가 (순환 방지)
    }
    return eligible;
  }, []);
}

ㅡㅡㅡㅡㅡㅡㅡ




function getEligibleNodes(nodes, links, selectedNodeId) {
  // 선택된 노드의 모든 자식 노드를 찾는 함수
  function findAllChildren(nodeId, visited = new Set()) {
    visited.add(nodeId);
    links.forEach(link => {
      if (link.from === nodeId && !visited.has(link.to)) {
        findAllChildren(link.to, visited);
      }
    });
    return visited;
  }

  // 선택된 노드와 그 모든 자식 노드의 ID를 Set으로 저장
  const excludedNodeIds = findAllChildren(selectedNodeId);

  const fromLinkCounts = links.reduce((counts, link) => {
    counts[link.from] = (counts[link.from] || 0) + 1;
    return counts;
  }, {});

  const typeConditions = {
    branch: node => (fromLinkCounts[node.id] || 0) <= 1,
    loss: node => !(fromLinkCounts[node.id] || 0),
    leaf: () => true
  };

  return nodes.filter(node => 
    !excludedNodeIds.has(node.id) &&
    node.id !== selectedNodeId &&
    typeConditions[node.type]?.(node)
  );
}



function getEligibleToNodes(nodes, links, selectedNodeId) {
  function findAllChildren(nodeId, visited = new Set()) {
    visited.add(nodeId);
    links.forEach(link => {
      if (link.from === nodeId && !visited.has(link.to)) {
        findAllChildren(link.to, visited);
      }
    });
    return visited;
  }

  const excludedNodeIds = findAllChildren(selectedNodeId);

  const toLinkCounts = links.reduce((counts, link) => {
    counts[link.to] = (counts[link.to] || 0) + 1;
    return counts;
  }, {});

  const typeConditions = {
    branch: () => true,
    loss: node => (toLinkCounts[node.id] || 0) <= 1,
    leaf: () => false
  };

  return nodes.filter(node => 
    !excludedNodeIds.has(node.id) &&
    node.id !== selectedNodeId &&
    typeConditions[node.type]?.(node)
  );
}









// 선택된 노드의 모든 자식 노드를 찾는 재귀 함수
function findAllChildren(nodeId, links) {
  const visited = new Set();

  function traverse(currentNodeId) {
    visited.add(currentNodeId);
    links.forEach(link => {
      if (link.from === currentNodeId && !visited.has(link.to)) {
        traverse(link.to);
      }
    });
  }

  traverse(nodeId);
  return visited;
}

// getEligibleNodes 함수
function getEligibleNodes(nodes, links, selectedNodeId) {
  const excludedNodeIds = findAllChildren(selectedNodeId, links); // 선택된 노드와 모든 자식 노드의 ID

  const fromLinkCounts = links.reduce((counts, link) => {
    counts[link.from] = (counts[link.from] || 0) + 1;
    return counts;
  }, {});

  const typeConditions = {
    branch: node => (fromLinkCounts[node.id] || 0) <= 1,
    loss: node => !(fromLinkCounts[node.id] || 0),
    leaf: () => true
  };

  return nodes.filter(node => 
    !excludedNodeIds.has(node.id) &&
    node.id !== selectedNodeId &&
    typeConditions[node.type]?.(node)
  );
}
