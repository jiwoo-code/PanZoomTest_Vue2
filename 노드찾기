function getEligibleNodes(nodes, links, selectedNodeId) {
  const connectedNodeIds = new Set(links
    .filter(link => link.from === selectedNodeId || link.to === selectedNodeId)
    .map(link => (link.from === selectedNodeId ? link.to : link.from)));

  const fromLinkCounts = links.reduce((counts, link) => {
    counts[link.from] = (counts[link.from] || 0) + 1;
    return counts;
  }, {});

  const visited = new Set(); // 순환 방지를 위한 방문 기록

  const typeConditions = {
    branch: node => (fromLinkCounts[node.id] || 0) <= 1,
    loss: node => !(fromLinkCounts[node.id] || 0),
    leaf: () => true
  };

  return nodes.reduce((eligible, node) => {
    if (
      !connectedNodeIds.has(node.id) &&
      node.id !== selectedNodeId &&
      !visited.has(node.id) && // 순환 방지 조건 추가
      typeConditions[node.type]?.(node)
    ) {
      eligible.push(node);
      visited.add(node.id); // 방문 기록 추가
    }
    return eligible;
  }, []);
}



function getEligibleToNodes(nodes, links, selectedNodeId) {
  // ... (이전 코드와 동일)

  const visited = new Set(); // 순환 방지를 위한 방문 기록

  return nodes.reduce((eligible, node) => {
    if (
      !connectedNodeIds.has(node.id) &&
      node.id !== selectedNodeId &&
      !visited.has(node.id) && // 순환 방지 조건 추가
      typeConditions[node.type]?.(node)
    ) {
      eligible.push(node);
      visited.add(node.id); // 방문 기록 추가
    }
    return eligible;
  }, []);
}
