1) Vue2 (ìš”ì²­ ì „ì†¡)
ì½”ë“œ ë³µì‚¬
Html
<!-- ì˜ˆ: Vue2 ì»´í¬ë„ŒíŠ¸ -->
<template>
  <div>
    <!-- ì˜ˆì‹œ ë²„íŠ¼ -->
    <button @click="fetchReport">ì¡°íšŒ</button>
  </div>
</template>

<script>
import axios from 'axios';

export default {
  name: 'ReportSearch',
  data() {
    return {
      schemaList: ['fab_a', 'fab_b', 'fab_a'], // ì˜ˆì‹œ
      eqpList:    ['EQP001', 'EQP777', 'EQP002'], // ì˜ˆì‹œ (ê°™ì€ ê¸¸ì´)
      startDate:  '2025-08-01 00:00:00',
      endDate:    '2025-08-31 23:59:59',
    };
  },
  methods: {
    async fetchReport() {
      const payload = {
        schemas: this.schemaList,
        eqpIds:  this.eqpList,
        startDate: this.startDate,
        endDate:   this.endDate,
      };
      try {
        const res = await axios.post('/api/report/search', payload);
        console.log('rows:', res.data);
      } catch (err) {
        console.error(err.response ? err.response.data : err);
      }
    }
  }
};
</script>
2) ìš”ì²­ DTO
ì½”ë“œ ë³µì‚¬
Java
// src/main/java/your/pkg/dto/ReportSearchRequest.java
package your.pkg.dto;

import java.util.List;
import javax.validation.constraints.NotEmpty;
import javax.validation.constraints.NotNull;

public class ReportSearchRequest {
    @NotNull @NotEmpty
    private List<String> schemas;   // ìŠ¤í‚¤ë§ˆ ëª©ë¡

    @NotNull @NotEmpty
    private List<String> eqpIds;    // eqp ëª©ë¡ (schemasì™€ ê¸¸ì´ ë™ì¼í•´ì•¼ í•¨)

    @NotNull
    private String startDate;       // ì˜ˆ: "yyyy-MM-dd HH:mm:ss"

    @NotNull
    private String endDate;

    // getters / setters
    public List<String> getSchemas() { return schemas; }
    public void setSchemas(List<String> schemas) { this.schemas = schemas; }

    public List<String> getEqpIds() { return eqpIds; }
    public void setEqpIds(List<String> eqpIds) { this.eqpIds = eqpIds; }

    public String getStartDate() { return startDate; }
    public void setStartDate(String startDate) { this.startDate = startDate; }

    public String getEndDate() { return endDate; }
    public void setEndDate(String endDate) { this.endDate = endDate; }
}
3) ì»¨íŠ¸ë¡¤ëŸ¬
ì½”ë“œ ë³µì‚¬
Java
// src/main/java/your/pkg/controller/ReportController.java
package your.pkg.controller;

import your.pkg.dto.ReportSearchRequest;
import your.pkg.service.ReportService;
import your.pkg.vo.ReportVo;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;

import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/report")
@Validated
public class ReportController {

    private final ReportService reportService;
    public ReportController(ReportService reportService) {
        this.reportService = reportService;
    }

    @PostMapping("/search")
    public ResponseEntity<List<ReportVo>> search(@Valid @RequestBody ReportSearchRequest req) {
        List<ReportVo> rows = reportService.searchGrouped(req);
        return ResponseEntity.ok(rows);
    }
}
4) ì„œë¹„ìŠ¤ (ìŠ¤í‚¤ë§ˆ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê²€ì¦ + (schemaâ†’ids) ê·¸ë£¹í•‘)
ì½”ë“œ ë³µì‚¬
Java
// src/main/java/your/pkg/service/ReportService.java
package your.pkg.service;

import your.pkg.dto.ReportSearchRequest;
import your.pkg.vo.ReportVo;

import java.util.List;

public interface ReportService {
    List<ReportVo> searchGrouped(ReportSearchRequest req);
}
ì½”ë“œ ë³µì‚¬
Java
// src/main/java/your/pkg/service/ReportServiceImpl.java
package your.pkg.service;

import your.pkg.dto.ReportSearchRequest;
import your.pkg.mapper.ReportMapper;
import your.pkg.vo.ReportVo;

import org.springframework.stereotype.Service;

import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
public class ReportServiceImpl implements ReportService {

    private final ReportMapper reportMapper;

    public ReportServiceImpl(ReportMapper reportMapper) {
        this.reportMapper = reportMapper;
    }

    // ìŠ¤í‚¤ë§ˆëª… í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ (ì˜ë¬¸/ìˆ«ì/ì–¸ë”ìŠ¤ì½”ì–´, ìˆ«ì ì‹œì‘ ê¸ˆì§€)
    private static final Pattern SCHEMA = Pattern.compile("^[A-Za-z_][A-Za-z0-9_]*$");

    @Override
    public List<ReportVo> searchGrouped(ReportSearchRequest req) {
        List<String> schemas = req.getSchemas();
        List<String> eqpIds  = req.getEqpIds();

        if (schemas.size() != eqpIds.size()) {
            throw new IllegalArgumentException("schemasì™€ eqpIds ê¸¸ì´ê°€ ë‹¤ë¦…ë‹ˆë‹¤.");
        }

        // ìŠ¤í‚¤ë§ˆ ê²€ì¦
        for (String s : schemas) {
            if (s == null || !SCHEMA.matcher(s).matches()) {
                throw new IllegalArgumentException("ì˜ëª»ëœ ìŠ¤í‚¤ë§ˆëª…: " + s);
            }
        }

        // (schema â†’ List<eqpId>) ê·¸ë£¹í•‘
        Map<String, List<String>> groups = new LinkedHashMap<>();
        for (int i = 0; i < schemas.size(); i++) {
            String sch = schemas.get(i);
            String id  = eqpIds.get(i);
            groups.computeIfAbsent(sch, k -> new ArrayList<>()).add(id);
        }

        // í•„ìš”ì‹œ eqpId ì¤‘ë³µ ì œê±°
        groups.replaceAll((k, v) -> v.stream().distinct().collect(Collectors.toList()));

        // ë‚ ì§œëŠ” ë§¤í¼ë¡œ ê·¸ëŒ€ë¡œ ì „ë‹¬ (ì¿¼ë¦¬ ì¡°ê±´ì€ ë§¤í¼ì—ì„œ êµ¬ì„±)
        return reportMapper.selectReportGrouped(groups, req.getStartDate(), req.getEndDate());
    }
}
5) ë§¤í¼ ì¸í„°í˜ì´ìŠ¤
ì½”ë“œ ë³µì‚¬
Java
// src/main/java/your/pkg/mapper/ReportMapper.java
package your.pkg.mapper;

import your.pkg.vo.ReportVo;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Map;

public interface ReportMapper {

    // groups: Map<schema, List<eqpId>>
    List<ReportVo> selectReportGrouped(
        @Param("groups")   Map<String, List<String>> groups,
        @Param("startDate") String startDate,
        @Param("endDate")   String endDate
    );
}
6) ë§¤í¼ XML (ìŠ¤í‚¤ë§ˆë³„ ë¸”ë¡ Ã— ids CTE join)
ë‚ ì§œ ì¡°ê±´ì€ ì§€ìš°ë‹˜ì´ ì§ì ‘ ë„£ìœ¼ì‹œê¸°ë¡œ í•´ì„œ ì£¼ì„ ìœ„ì¹˜ë§Œ í‘œì‹œí•´ ë‘¡ë‹ˆë‹¤.
${schema}ëŠ” ì‹ë³„ì ì¹˜í™˜ì´ë¯€ë¡œ ë°˜ë“œì‹œ ì„œë¹„ìŠ¤ì—ì„œ ì •ê·œì‹ ê²€ì¦ í›„ ë„˜ì–´ì˜µë‹ˆë‹¤.
ì½”ë“œ ë³µì‚¬
Xml
<!-- src/main/resources/your/pkg/mapper/ReportMapper.xml -->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="your.pkg.mapper.ReportMapper">

  <!-- resultMapì€ ì‹¤ì œ ì»¬ëŸ¼ì— ë§ê²Œ ì‘ì„± -->
  <resultMap id="reportMap" type="your.pkg.vo.ReportVo">
    <result property="eqpId" column="eqp_id"/>
    <!-- ë‚˜ë¨¸ì§€ ì»¬ëŸ¼ ë§¤í•‘ -->
  </resultMap>

<select id="selectReportGrouped" resultMap="reportMap">
  SELECT * FROM (
    <foreach collection="groups" index="schema" item="ids" separator=" UNION ALL ">
      WITH
      ids(eqp_id) AS (
        SELECT UNNEST(ARRAY[
          <foreach collection="ids" item="id" separator=",">
            #{id}
          </foreach>
        ])
      ),

      -- dose_shot: ê¸°ì¡´ëŒ€ë¡œ ids ì¡°ì¸
      dose_shot AS (
        SELECT
          st.eqp_id
          -- , ...
        FROM some_table st
        JOIN ids ON ids.eqp_id = st.eqp_id
        -- AND st.occurred_at BETWEEN #{startDate} AND #{endDate}
        GROUP BY st.eqp_id
        -- , ...
      ),

      -- slip: ê¸°ì¡´ëŒ€ë¡œ ids ì¡°ì¸
      slip AS (
        SELECT
          sp.eqp_id
          -- , ...
        FROM slip_table sp
        JOIN ids ON ids.eqp_id = sp.eqp_id
        -- AND sp.ts BETWEEN #{startDate} AND #{endDate}
      ),

      -- ğŸ”‘ eff_rate: ids -> eqp_info ë§¤í•‘(eqp_id_2) ì§‘í•©ì„ ë§Œë“¤ì–´ x.eqp_idì™€ JOIN
      eqp_map AS (
        SELECT DISTINCT ei.eqp_id_2 AS eqp_id
        FROM eqp_info ei
        JOIN ids ON ei.eqp_id = ids.eqp_id
      ),
      eff_rate AS (
        SELECT
          t.eqp_id
          -- , ...
        FROM (
          SELECT
            x.eqp_id
            -- , ...
          FROM ${schema}.table x             <!-- ìŠ¤í‚¤ë§ˆë§Œ ë™ì  ì‹ë³„ì -->
          JOIN eqp_map m ON m.eqp_id = x.eqp_id
          -- AND x.dt BETWEEN #{startDate} AND #{endDate}
        ) t
      ),

      reticle AS (
        SELECT
          t.eqp_id,
          AVG(t.metric) * 100 AS rate
        FROM (
          SELECT
            std.eqp_id,
            CASE
              WHEN LAG(std.flag) OVER (PARTITION BY std.eqp_id ORDER BY std.ts) IS NULL
              THEN 1 ELSE 0
            END AS metric
          FROM std_table std
          JOIN ids ON ids.eqp_id = std.eqp_id
          <include refid="where.range">
            <property name="dateCol" value="std.ts"/>
          </include>
          <include refid="where.seqOne">
            <property name="seqCol" value="std.seq"/>
          </include>
        ) t
        GROUP BY t.eqp_id
      )

      SELECT
        er.eqp_id
        -- , er.col_a, rt.col_b, ds.col_c, sp.col_d ...
      FROM eff_rate   er
      JOIN reticle    rt ON rt.eqp_id = er.eqp_id
      JOIN dose_shot  ds ON ds.eqp_id = er.eqp_id
      JOIN slip       sp ON sp.eqp_id = er.eqp_id
    </foreach>
  ) u
</select>
</mapper>
7) ê²°ê³¼ VO (ì˜ˆì‹œ)
ì½”ë“œ ë³µì‚¬
Java
// src/main/java/your/pkg/vo/ReportVo.java
package your.pkg.vo;

public class ReportVo {
    private String eqpId;
    // private ... (í•„ìš”í•œ ì»¬ëŸ¼ë“¤)

    public String getEqpId() { return eqpId; }
    public void setEqpId(String eqpId) { this.eqpId = eqpId; }






ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡

1) Service
1-1. ì¸í„°í˜ì´ìŠ¤
ì½”ë“œ ë³µì‚¬
Java
// src/main/java/your/pkg/service/ReportService.java
package your.pkg.service;

import your.pkg.vo.ReportVo;
import java.util.List;

public interface ReportService {
    List<ReportVo> searchReport(
        List<String> schemas,    // ìŠ¤í‚¤ë§ˆ ë°°ì—´ (eqpIdsì™€ ê°™ì€ ê¸¸ì´)
        List<String> eqpIds,     // eqp ë°°ì—´ (schemasì™€ ê°™ì€ ì¸ë±ìŠ¤ê°€ í˜ì–´)
        String startDate,        // "yyyy-MM-dd HH:mm:ss" ë“±
        String endDate
    );
}
1-2. êµ¬í˜„
ì½”ë“œ ë³µì‚¬
Java
// src/main/java/your/pkg/service/ReportServiceImpl.java
package your.pkg.service;

import your.pkg.mapper.ReportMapper;
import your.pkg.vo.ReportVo;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
public class ReportServiceImpl implements ReportService {

    private final ReportMapper reportMapper;
    public ReportServiceImpl(ReportMapper reportMapper) {
        this.reportMapper = reportMapper;
    }

    private static final Pattern SCHEMA = Pattern.compile("^[A-Za-z_][A-Za-z0-9_]*$");

    @Override
    public List<ReportVo> searchReport(List<String> schemas, List<String> eqpIds, String startDate, String endDate) {
        if (schemas == null || eqpIds == null || schemas.size() != eqpIds.size()) {
            throw new IllegalArgumentException("schemasì™€ eqpIds ê¸¸ì´ê°€ ë‹¤ë¦…ë‹ˆë‹¤.");
        }

        // ìŠ¤í‚¤ë§ˆ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê²€ì¦
        for (String s : schemas) {
            if (s == null || !SCHEMA.matcher(s).matches()) {
                throw new IllegalArgumentException("ì˜ëª»ëœ ìŠ¤í‚¤ë§ˆëª…: " + s);
            }
        }

        // ìŠ¤í‚¤ë§ˆâ†’EQP ë¦¬ìŠ¤íŠ¸ ê·¸ë£¹í•‘ (eff_rate UNIONì— ì‚¬ìš©)
        Map<String, List<String>> groups = new LinkedHashMap<>();
        // ì „ì²´ EQP (dose_shot/reticle/slip ê³µí†µ IN (...)ì— ì‚¬ìš©)
        Set<String> allEqp = new LinkedHashSet<>();

        for (int i = 0; i < schemas.size(); i++) {
            String sch = schemas.get(i);
            String id  = eqpIds.get(i);
            if (id == null || id.isEmpty()) continue;
            groups.computeIfAbsent(sch, k -> new ArrayList<>()).add(id);
            allEqp.add(id);
        }

        // ì¤‘ë³µ ì œê±°
        groups.replaceAll((k, v) -> v.stream().distinct().collect(Collectors.toList()));
        List<String> allEqpIds = new ArrayList<>(allEqp);

        return reportMapper.selectReport(allEqpIds, groups, startDate, endDate);
    }
}
2) Mapper ì¸í„°í˜ì´ìŠ¤
ì½”ë“œ ë³µì‚¬
Java
// src/main/java/your/pkg/mapper/ReportMapper.java
package your.pkg.mapper;

import your.pkg.vo.ReportVo;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Map;

public interface ReportMapper {
    List<ReportVo> selectReport(
        @Param("allEqpIds") List<String> allEqpIds,            // ëª¨ë“  EQP(ì¤‘ë³µ ì œê±°)
        @Param("groups")    Map<String, List<String>> groups,  // ìŠ¤í‚¤ë§ˆâ†’EQP ë¦¬ìŠ¤íŠ¸
        @Param("startDate") String startDate,
        @Param("endDate")   String endDate
    );
}
3) Mapper XML
NOTE
dose_shot/reticleì—ë§Œ where.ã…‡ã…‡ã…‡ include ì‚¬ìš©.
eff_rate_unionì—ì„œë§Œ ìŠ¤í‚¤ë§ˆë³„ UNION ALL + eqp_info.eqp_id_2 IS NOT NULL í•„í„°.
${schema}ëŠ” ì‹ë³„ì ì¹˜í™˜ì´ë¯€ë¡œ ë°˜ë“œì‹œ ì„œë¹„ìŠ¤ì—ì„œ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê²€ì¦(ì´ë¯¸ êµ¬í˜„).
ìµœì¢… SELECT ì»¬ëŸ¼ì€ ì˜ˆì‹œ(eqp_id, eff_rate, dose_shot_rate, reticle_rate). ì‹¤ì œë¡œ í•„ìš”í•œ ì»¬ëŸ¼/ë³„ì¹­ì— ë§ì¶° resultMapê³¼ í•¨ê»˜ ìˆ˜ì •í•˜ì„¸ìš”.
ì½”ë“œ ë³µì‚¬
Xml
<!-- src/main/resources/your/pkg/mapper/ReportMapper.xml -->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="your.pkg.mapper.ReportMapper">

  <!-- í•„ìš”í•œ ì»¬ëŸ¼ì— ë§ê²Œ ìˆ˜ì • -->
  <resultMap id="reportMap" type="your.pkg.vo.ReportVo">
    <result property="eqpId"          column="eqp_id"/>
    <result property="effRate"        column="eff_rate"/>
    <result property="doseShotRate"   column="dose_shot_rate"/>
    <result property="reticleRate"    column="reticle_rate"/>
  </resultMap>

  <select id="selectReport" resultMap="reportMap">
    WITH
    dose_shot AS (
      SELECT t.eqp_id, AVG(t.metric) * 100 AS rate
      FROM (
        SELECT
          st.eqp_id,
          CASE
            WHEN ROW_NUMBER() OVER (PARTITION BY st.eqp_id ORDER BY st.ts) = 1 THEN 1
            ELSE 0
          END AS metric
        FROM some_table st
        WHERE st.eqp_id IN (
          <foreach collection="allEqpIds" item="id" separator=","> #{id} </foreach>
        )
        <include refid="where.ã…‡ã…‡ã…‡">
          <property name="dddd"      value="ddd"/>
          <property name="startDate" value="#{startDate}"/>
          <property name="endDate"   value="#{endDate}"/>
        </include>
        AND st.seq = 1
      ) t
      GROUP BY t.eqp_id
    ),
    reticle AS (
      SELECT t.eqp_id, AVG(t.metric) * 100 AS rate
      FROM (
        SELECT
          std.eqp_id,
          CASE
            WHEN LAG(std.flag) OVER (PARTITION BY std.eqp_id ORDER BY std.ts) IS NULL THEN 1
            ELSE 0
          END AS metric
        FROM std_table std
        WHERE std.eqp_id IN (
          <foreach collection="allEqpIds" item="id" separator=","> #{id} </foreach>
        )
        <include refid="where.ã…‡ã…‡ã…‡">
          <property name="dddd"      value="ddd"/>
          <property name="startDate" value="#{startDate}"/>
          <property name="endDate"   value="#{endDate}"/>
        </include>
        AND std.seq = 1
      ) t
      GROUP BY t.eqp_id
    ),
    slip AS (
      SELECT sp.eqp_id
      FROM slip_table sp
      WHERE sp.eqp_id IN (
        <foreach collection="allEqpIds" item="id" separator=","> #{id} </foreach>
      )
    ),
    eff_rate_union AS (
      <foreach collection="groups.entrySet()" item="e" separator=" UNION ALL ">
        <bind name="schema" value="e.key"/>
        SELECT
          x.eqp_id,
          AVG(x.val) AS eff_rate
        FROM ${schema}.table x
        WHERE x.eqp_id IN (
          SELECT DISTINCT ei.eqp_id_2
          FROM eqp_info ei
          JOIN (
            SELECT UNNEST(ARRAY[
              <foreach collection="e.value" item="id" separator=","> #{id} </foreach>
            ]) AS eqp_id
          ) s ON s.eqp_id = ei.eqp_id
          WHERE ei.eqp_id_2 IS NOT NULL
            AND ei.eqp_id_2 <> ''
        )
        GROUP BY x.eqp_id
      </foreach>
    )
    SELECT
      er.eqp_id,
      er.eff_rate,
      ds.rate AS dose_shot_rate,
      rt.rate AS reticle_rate
    FROM eff_rate_union er
    JOIN dose_shot ds ON ds.eqp_id = er.eqp_id
    JOIN reticle  rt ON rt.eqp_id = er.eqp_id
    JOIN slip     sp ON sp.eqp_id = er.eqp_id
  </select>
</mapper>