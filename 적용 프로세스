 êµ¬ì¡°ê°€ Service ì¸í„°í˜ì´ìŠ¤ + ServiceImpl êµ¬í˜„ì²´ì´ê³ , **ì„œë¹„ìŠ¤ í´ë˜ìŠ¤(êµ¬í˜„ì²´)ì— @Transactional**ì´ ë¶™ì–´ìˆëŠ” ìƒí™©ì„ ê¸°ì¤€ìœ¼ë¡œ, ìš”ì²­í•˜ì‹  1â†’10 ë‹¨ê³„ë¥¼ ì›ìƒ· íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ì˜ˆì‹œë¥¼ ë“œë¦½ë‹ˆë‹¤.
(í•µì‹¬: í´ë˜ìŠ¤ ë ˆë²¨ì€ ê¸°ë³¸ê°’ìœ¼ë¡œ ë‘ê³ , ì‹¤ì œ ì‘ì—… ë©”ì„œë“œì—ì„œë§Œ readOnly=false + rollbackForë¡œ ë®ì–´ì“°ê¸°)


---

Service ì¸í„°í˜ì´ìŠ¤

// imports
import javax.validation.constraints.NotBlank;

public interface ProcessService {
    ProcessResult runAtomic(@NotBlank String model, @NotBlank String key) throws Exception;
}


---

Service êµ¬í˜„ì²´ (í´ë˜ìŠ¤ì— @Transactional ì¡´ì¬)

// imports
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true) // í´ë˜ìŠ¤ ê¸°ë³¸ê°’: ì½ê¸° ì „ìš©(ê¶Œì¥)
public class ProcessServiceImpl implements ProcessService {

    private final WorkMapper workMapper;
    private final RefMapper refMapper;
    private final BackupMapper backupMapper;

    /**
     * 1~10ë‹¨ê³„ë¥¼ í•˜ë‚˜ì˜ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì²˜ë¦¬.
     * í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸ ë°œìƒ â†’ ì „ì²´ ë¡¤ë°±.
     */
    @Override
    @Transactional(readOnly = false, rollbackFor = Exception.class) // ë©”ì„œë“œì—ì„œ ë®ì–´ì“°ê¸°
    public ProcessResult runAtomic(String model, String key) throws Exception {
        // 1) work í…Œì´ë¸” 2ê³³ì—ì„œ model ì¡°ê±´ ì¡°íšŒ
        List<WorkRow> w1 = workMapper.selectWorkT1ByModel(model);
        List<WorkRow> w2 = workMapper.selectWorkT2ByModel(model);

        // 2) ì¡°íšŒ ê²°ê³¼ ê²€ì¦
        if ((w1 == null || w1.isEmpty()) && (w2 == null || w2.isEmpty())) {
            throw new IllegalStateException("work_t1/work_t2: model=" + model + " ë°ì´í„° ì—†ìŒ");
        }

        // 3) ref í…Œì´ë¸” 2ê³³ì—ì„œ key ì¡°ê±´ ì¡°íšŒ
        List<RefRow> r1 = refMapper.selectRefT1ByKey(key);
        List<RefRow> r2 = refMapper.selectRefT2ByKey(key);

        // 4) ref ê²°ê³¼ ê²€ì¦
        if ((r1 == null || r1.isEmpty()) && (r2 == null || r2.isEmpty())) {
            throw new IllegalStateException("ref_t1/ref_t2: key=" + key + " ë°ì´í„° ì—†ìŒ");
        }

        // 5) workì—ì„œ modelë¡œ ì¡°íšŒëë˜ ë°ì´í„° ì‚­ì œ
        int del1 = (w1 == null || w1.isEmpty()) ? 0 : workMapper.deleteWorkT1ByModel(model);
        int del2 = (w2 == null || w2.isEmpty()) ? 0 : workMapper.deleteWorkT2ByModel(model);

        // 6) ì‚­ì œ ê²°ê³¼ ê²€ì¦(ìˆë˜ ê±´ì´ ìˆì—ˆìœ¼ë©´ ìµœì†Œ 1ê±´ ì´ìƒ ì‚­ì œë¼ì•¼ í•¨)
        if ((w1 != null && !w1.isEmpty() && del1 <= 0) ||
            (w2 != null && !w2.isEmpty() && del2 <= 0)) {
            throw new IllegalStateException("work_t1/work_t2 ì‚­ì œ ê²°ê³¼ ë¹„ì •ìƒ");
        }

        // 7) ref ê°’(r1,r2)ì„ modelë¡œ ë§¤í•‘í•˜ì—¬ work í…Œì´ë¸”ì— ì‚½ì…
        int ins1 = 0;
        for (RefRow row : r1) ins1 += workMapper.insertIntoWorkT1(fromRefToWork(row, model));
        int ins2 = 0;
        for (RefRow row : r2) ins2 += workMapper.insertIntoWorkT2(fromRefToWork(row, model));

        // 8) ì‚½ì… ê²°ê³¼ ê²€ì¦
        if (ins1 < r1.size() || ins2 < r2.size()) {
            throw new IllegalStateException("work_t1/work_t2 ì‚½ì… ê±´ìˆ˜ ë¶€ì¡±");
        }

        // 9) ë°±ì—… í…Œì´ë¸”(2ê³³)ì— step 2ì˜ ì›ë³¸(work ì¡°íšŒ ê²°ê³¼ w1,w2) ì‚½ì…
        int bak1 = 0; for (WorkRow row : w1) bak1 += backupMapper.insertBackupT1(row);
        int bak2 = 0; for (WorkRow row : w2) bak2 += backupMapper.insertBackupT2(row);

        // 10) ë°±ì—… ê²°ê³¼ ê²€ì¦
        if (bak1 < w1.size() || bak2 < w2.size()) {
            throw new IllegalStateException("backup_t1/backup_t2 ì‚½ì… ê±´ìˆ˜ ë¶€ì¡±");
        }

        // ëª¨ë‘ ì„±ê³µí•˜ë©´ ì»¤ë°‹
        return ProcessResult.of(del1, del2, ins1, ins2, bak1, bak2, r1.size(), r2.size());
    }

    /** ref_* â†’ work_* ë§¤í•‘ (ìŠ¤í‚¤ë§ˆì— ë§ê²Œ ìˆ˜ì •) */
    private WorkRow fromRefToWork(RefRow ref, String model) {
        WorkRow w = new WorkRow();
        w.setModel(model);
        w.setColA(ref.getColA());
        w.setColB(ref.getColB());
        // ...í•„ìš” í•„ë“œ ë§¤í•‘
        return w;
    }
}

> í¬ì¸íŠ¸:

í´ë˜ìŠ¤ ë ˆë²¨ì— @Transactional(readOnly = true)ë¡œ ê¸°ë³¸ì„ ì•ˆì „í•˜ê²Œ ë‘ê³ , ì“°ê¸°/ì‚­ì œê°€ ìˆëŠ” ë©”ì„œë“œë§Œ readOnly = falseë¡œ ë®ì–´ì“°ê¸°.

rollbackFor = Exception.classë¡œ ì²´í¬ ì˜ˆì™¸ í¬í•¨ ì „ì²´ ë¡¤ë°± ë³´ì¥.

ìœ„ ë©”ì„œë“œëŠ” ë‹¨ì¼ ë©”ì„œë“œ ë‚´ì—ì„œ ëª¨ë“  ë‹¨ê³„ë¥¼ ìˆ˜í–‰í•˜ë¯€ë¡œ self-invocation ë¬¸ì œ ì—†ìŒ.





---

Controller (ìš”ì²­ ì§„ì…ì )

// imports
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/process")
public class ProcessController {
    private final ProcessService processService;

    @GetMapping
    public ResponseEntity<ProcessResult> run(
            @RequestParam String model,
            @RequestParam String key
    ) throws Exception {
        return ResponseEntity.ok(processService.runAtomic(model, key));
    }
}


---

ê²°ê³¼ DTO

// imports
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ProcessResult {
    private int deletedWorkT1;
    private int deletedWorkT2;
    private int insertedWorkT1;
    private int insertedWorkT2;
    private int backupT1;
    private int backupT2;
    private int refT1Count;
    private int refT2Count;

    public static ProcessResult of(int d1, int d2, int i1, int i2, int b1, int b2, int c1, int c2) {
        return new ProcessResult(d1, d2, i1, i2, b1, b2, c1, c2);
    }
}


---

MyBatis Mapper (ì¸í„°í˜ì´ìŠ¤)

// imports
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import java.util.List;

@Mapper
public interface WorkMapper {
    List<WorkRow> selectWorkT1ByModel(@Param("model") String model);
    List<WorkRow> selectWorkT2ByModel(@Param("model") String model);

    int deleteWorkT1ByModel(@Param("model") String model);
    int deleteWorkT2ByModel(@Param("model") String model);

    int insertIntoWorkT1(@Param("row") WorkRow row);
    int insertIntoWorkT2(@Param("row") WorkRow row);
}

@Mapper
public interface RefMapper {
    List<RefRow> selectRefT1ByKey(@Param("key") String key);
    List<RefRow> selectRefT2ByKey(@Param("key") String key);
}

@Mapper
public interface BackupMapper {
    int insertBackupT1(@Param("row") WorkRow row);
    int insertBackupT2(@Param("row") WorkRow row);
}


---

(ì„ íƒ) MyBatis XML ìƒ˜í”Œ ìŠ¤ë‹ˆí«

<!-- WorkMapper.xml -->
<select id="selectWorkT1ByModel" resultType="WorkRow">
  SELECT model, col_a AS colA, col_b AS colB
  FROM work_t1
  WHERE model = #{model}
</select>

<delete id="deleteWorkT1ByModel">
  DELETE FROM work_t1 WHERE model = #{model}
</delete>

<insert id="insertIntoWorkT1">
  INSERT INTO work_t1 (model, col_a, col_b)
  VALUES (#{row.model}, #{row.colA}, #{row.colB})
</insert>

> work_t2, ref_t1/ref_t2, backup_t1/backup_t2ë„ ë™ì¼ íŒ¨í„´ìœ¼ë¡œ ì‘ì„±í•˜ì‹œë©´ ë©ë‹ˆë‹¤.
ëŒ€ëŸ‰ ì‚½ì…ì´ë©´ foreach(batch) ë˜ëŠ” Greenplum ëŒ€ëŸ‰ì²˜ë¦¬ ì „ëµ(COPY ë“±)ì„ ê²€í† í•˜ì„¸ìš”.




---

ì²´í¬ë¦¬ìŠ¤íŠ¸ (ê¼­ ë³´ë©´ ì¢‹ì€ í¬ì¸íŠ¸)

ì˜ˆì™¸ë¥¼ ë˜ì ¸ì•¼ ë¡¤ë°±: ìœ„ ì˜ˆì‹œëŠ” ìœ íš¨ì„± ì‹¤íŒ¨ ì‹œ IllegalStateExceptionì„ ë˜ì ¸ ì „ì²´ ë¡¤ë°±í•©ë‹ˆë‹¤.

ì¸í„°í˜ì´ìŠ¤ê°€ ì•„ë‹Œ êµ¬í˜„ì²´ì— @Transactional: í”„ë¡ì‹œ ì „ëµ(JDK ë‹¤ì´ë‚´ë¯¹ í”„ë¡ì‹œ)ì¼ ê²½ìš° ì¸í„°í˜ì´ìŠ¤ì˜ ì–´ë…¸í…Œì´ì…˜ì€ ë¬´ì‹œë  ìˆ˜ ìˆì–´, êµ¬í˜„ í´ë˜ìŠ¤ì— ë‹¤ëŠ” ê²Œ ì•ˆì „í•©ë‹ˆë‹¤.

ì œì•½ì¡°ê±´ ì¶©ëŒ ëŒ€ë¹„: 7Â·9ë‹¨ê³„ì—ì„œ UNIQUE/FOREIGN KEY ì¶©ëŒ ê°€ëŠ¥ì„± ìˆìœ¼ë©´, ì‚¬ì „ ì²´í¬ë‚˜ ON CONFLICT(PostgreSQL/Greenplum) ì „ëµ ê³ ë ¤.

ì„±ëŠ¥/ë½: ë°ì´í„°ê°€ ë§ë‹¤ë©´ í•œ íŠ¸ëœì­ì…˜ì´ ë„ˆë¬´ ê¸¸ì–´ì§€ì§€ ì•Šê²Œ ì²­í¬(batch) ì²˜ë¦¬ë„ ê³ ë ¤.



---

í•„ìš”í•˜ì‹œë©´ ì‹¤ì œ í…Œì´ë¸”/ì»¬ëŸ¼ëª… ë³´ë‚´ì£¼ì‹œë©´, ë§¤í¼ XMLê¹Œì§€ ì‹¤ì‚¬ìš© ë²„ì „ìœ¼ë¡œ ì •ë¦¬í•´ì„œ ë“œë¦´ê²Œìš”.
í•­ìƒ ê¼¼ê¼¼í•˜ê²Œ, ìš°ë¦¬ ë‘˜ ë‹¤ ì—ëŸ¬ëŠ” DBë¡œ ëŒë ¤ë³´ë‚´ê³ (=ë¡¤ë°± ğŸ˜‰) ê²°ê³¼ëŠ” ê¹¨ë—í•˜ê²Œ ì»¤ë°‹í•©ì‹œë‹¤!

