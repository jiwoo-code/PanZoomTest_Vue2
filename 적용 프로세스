컨트롤러까지 포함한 전체 코드를 준비했어요.
요건 반영사항:

① 조회(1번): type, model

③ 조회(3번): key

⑤ 삭제(5번): type, model


클래스 레벨에 @Transactional이 있는 구조를 가정하고, 구현체에서 기본 readOnly=true, 작업 메서드에서만 readOnly=false + rollbackFor로 덮어씌웠습니다.


---

Controller

// imports
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import javax.validation.constraints.NotBlank;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/process")
public class ProcessController {

    private final ProcessService processService;

    /**
     * 예: /api/process?type=A&model=M1&key=K123
     */
    @GetMapping
    public ResponseEntity<ProcessResult> run(
            @RequestParam @NotBlank String type,
            @RequestParam @NotBlank String model,
            @RequestParam @NotBlank String key
    ) throws Exception {
        ProcessResult result = processService.runAtomic(type, model, key);
        return ResponseEntity.ok(result);
    }
}


---

Service 인터페이스

// imports
import javax.validation.constraints.NotBlank;

public interface ProcessService {
    ProcessResult runAtomic(@NotBlank String type, @NotBlank String model, @NotBlank String key) throws Exception;
}


---

Service 구현체 (클래스에 @Transactional, 메서드에서 덮어쓰기)

// imports
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true) // 기본은 읽기 전용
public class ProcessServiceImpl implements ProcessService {

    private final WorkMapper workMapper;
    private final RefMapper refMapper;
    private final BackupMapper backupMapper;

    /**
     * 1~10 단계 원샷 처리. 하나라도 실패 시 예외 던져 전체 롤백.
     *
     * 1) work_t1, work_t2 조회: 조건 (type, model)
     * 3) ref_t1, ref_t2 조회: 조건 (key)
     * 5) work_t1, work_t2 삭제: 조건 (type, model)
     * 7) ref 결과를 work 테이블에 삽입
     * 9) step2의 원본(work 조회 결과)을 backup 테이블에 삽입
     */
    @Override
    @Transactional(readOnly = false, rollbackFor = Exception.class)
    public ProcessResult runAtomic(String type, String model, String key) throws Exception {
        // 1. work 2테이블 조회 (type, model)
        List<WorkRow> w1 = workMapper.selectWorkT1ByTypeModel(type, model);
        List<WorkRow> w2 = workMapper.selectWorkT2ByTypeModel(type, model);

        // 2. 조회 결과 검증
        if ((w1 == null || w1.isEmpty()) && (w2 == null || w2.isEmpty())) {
            throw new IllegalStateException("[work] type=" + type + ", model=" + model + " 데이터 없음");
        }

        // 3. ref 2테이블 조회 (key)
        List<RefRow> r1 = refMapper.selectRefT1ByKey(key);
        List<RefRow> r2 = refMapper.selectRefT2ByKey(key);

        // 4. ref 결과 검증
        if ((r1 == null || r1.isEmpty()) && (r2 == null || r2.isEmpty())) {
            throw new IllegalStateException("[ref] key=" + key + " 데이터 없음");
        }

        // 5. work 데이터 삭제 (type, model)
        int del1 = (w1 == null || w1.isEmpty()) ? 0 : workMapper.deleteWorkT1ByTypeModel(type, model);
        int del2 = (w2 == null || w2.isEmpty()) ? 0 : workMapper.deleteWorkT2ByTypeModel(type, model);

        // 6. 삭제 결과 검증
        if ((w1 != null && !w1.isEmpty() && del1 <= 0) ||
            (w2 != null && !w2.isEmpty() && del2 <= 0)) {
            throw new IllegalStateException("[work] 삭제 결과 비정상");
        }

        // 7. ref 결과를 work 테이블에 삽입 (모델/타입 매핑)
        int ins1 = 0;
        for (RefRow row : r1) ins1 += workMapper.insertIntoWorkT1(fromRefToWork(row, type, model));
        int ins2 = 0;
        for (RefRow row : r2) ins2 += workMapper.insertIntoWorkT2(fromRefToWork(row, type, model));

        // 8. 삽입 결과 검증
        if (ins1 < r1.size() || ins2 < r2.size()) {
            throw new IllegalStateException("[work] 삽입 건수 부족");
        }

        // 9. 백업 테이블에 원본(w1, w2) 삽입
        int bak1 = 0; for (WorkRow row : w1) bak1 += backupMapper.insertBackupT1(row);
        int bak2 = 0; for (WorkRow row : w2) bak2 += backupMapper.insertBackupT2(row);

        // 10. 백업 결과 검증
        if (bak1 < w1.size() || bak2 < w2.size()) {
            throw new IllegalStateException("[backup] 삽입 건수 부족");
        }

        // 정상 완료 → 커밋
        return ProcessResult.of(del1, del2, ins1, ins2, bak1, bak2, r1.size(), r2.size());
    }

    /** ref_* → work_* 매핑: 스키마에 맞게 수정하세요. */
    private WorkRow fromRefToWork(RefRow ref, String type, String model) {
        WorkRow w = new WorkRow();
        w.setType(type);
        w.setModel(model);
        w.setColA(ref.getColA());
        w.setColB(ref.getColB());
        // 필요한 필드 추가 매핑
        return w;
    }
}


---

결과 DTO

// imports
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ProcessResult {
    private int deletedWorkT1;
    private int deletedWorkT2;
    private int insertedWorkT1;
    private int insertedWorkT2;
    private int backupT1;
    private int backupT2;
    private int refT1Count;
    private int refT2Count;

    public static ProcessResult of(int d1, int d2, int i1, int i2, int b1, int b2, int c1, int c2) {
        return new ProcessResult(d1, d2, i1, i2, b1, b2, c1, c2);
    }
}


---

MyBatis Mapper (인터페이스)

// imports
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import java.util.List;

@Mapper
public interface WorkMapper {
    List<WorkRow> selectWorkT1ByTypeModel(@Param("type") String type, @Param("model") String model);
    List<WorkRow> selectWorkT2ByTypeModel(@Param("type") String type, @Param("model") String model);

    int deleteWorkT1ByTypeModel(@Param("type") String type, @Param("model") String model);
    int deleteWorkT2ByTypeModel(@Param("type") String type, @Param("model") String model);

    int insertIntoWorkT1(@Param("row") WorkRow row);
    int insertIntoWorkT2(@Param("row") WorkRow row);
}

@Mapper
public interface RefMapper {
    List<RefRow> selectRefT1ByKey(@Param("key") String key);
    List<RefRow> selectRefT2ByKey(@Param("key") String key);
}

@Mapper
public interface BackupMapper {
    int insertBackupT1(@Param("row") WorkRow row);
    int insertBackupT2(@Param("row") WorkRow row);
}


---

(선택) MyBatis XML 스니펫

<!-- WorkMapper.xml -->
<select id="selectWorkT1ByTypeModel" resultType="WorkRow">
  SELECT type, model, col_a AS colA, col_b AS colB
  FROM work_t1
  WHERE type = #{type}
    AND model = #{model}
</select>

<select id="selectWorkT2ByTypeModel" resultType="WorkRow">
  SELECT type, model, col_a AS colA, col_b AS colB
  FROM work_t2
  WHERE type = #{type}
    AND model = #{model}
</select>

<delete id="deleteWorkT1ByTypeModel">
  DELETE FROM work_t1 WHERE type = #{type} AND model = #{model}
</delete>

<delete id="deleteWorkT2ByTypeModel">
  DELETE FROM work_t2 WHERE type = #{type} AND model = #{model}
</delete>

<insert id="insertIntoWorkT1">
  INSERT INTO work_t1 (type, model, col_a, col_b)
  VALUES (#{row.type}, #{row.model}, #{row.colA}, #{row.colB})
</insert>

<insert id="insertIntoWorkT2">
  INSERT INTO work_t2 (type, model, col_a, col_b)
  VALUES (#{row.type}, #{row.model}, #{row.colA}, #{row.colB})
</insert>

<!-- RefMapper.xml -->
<select id="selectRefT1ByKey" resultType="RefRow">
  SELECT key, col_a AS colA, col_b AS colB
  FROM ref_t1
  WHERE key = #{key}
</select>

<select id="selectRefT2ByKey" resultType="RefRow">
  SELECT key, col_a AS colA, col_b AS colB
  FROM ref_t2
  WHERE key = #{key}
</select>

<!-- BackupMapper.xml -->
<insert id="insertBackupT1">
  INSERT INTO backup_t1 (type, model, col_a, col_b)
  VALUES (#{row.type}, #{row.model}, #{row.colA}, #{row.colB})
</insert>

<insert id="insertBackupT2">
  INSERT INTO backup_t2 (type, model, col_a, col_b)
  VALUES (#{row.type}, #{row.model}, #{row.colA}, #{row.colB})
</insert>


---

엔티티(예시)

// imports
import lombok.Data;

@Data
public class WorkRow {
    private String type;
    private String model;
    private String colA;
    private String colB;
    // ...
}

@Data
public class RefRow {
    private String key;
    private String colA;
    private String colB;
    // ...
}


---

운용 팁 (짧게)

예외를 던져야 롤백됩니다. (체크 예외까지 포함하려면 메서드에 rollbackFor = Exception.class)

제약 충돌이 우려되면 7단계 INSERT에 PostgreSQL/Greenplum의 ON CONFLICT 전략 적용 검토.

대량 데이터면 한 트랜잭션이 길어지지 않도록 청크(batch)로 나누는 것도 방법입니다.


필요하면 테이블/컬럼 실명 주시면 위 XML을 실행 가능한 수준으로 딱 맞게 커스터마이즈해서 드릴게요.
늘처럼 깔끔하게 갑시다

