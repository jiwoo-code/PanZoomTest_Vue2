ì§€ìš°ë‹˜, ë”± ë§ì¶°ì„œ ì»¨íŠ¸ë¡¤ëŸ¬ê¹Œì§€ í¬í•¨í•œ ì „ì²´ ì½”ë“œë¥¼ ì¤€ë¹„í–ˆì–´ìš”.
ìš”ê±´ ë°˜ì˜ì‚¬í•­:

â‘  ì¡°íšŒ(1ë²ˆ): type, model

â‘¢ ì¡°íšŒ(3ë²ˆ): key

â‘¤ ì‚­ì œ(5ë²ˆ): type, model


í´ë˜ìŠ¤ ë ˆë²¨ì— @Transactionalì´ ìˆëŠ” êµ¬ì¡°ë¥¼ ê°€ì •í•˜ê³ , êµ¬í˜„ì²´ì—ì„œ ê¸°ë³¸ readOnly=true, ì‘ì—… ë©”ì„œë“œì—ì„œë§Œ readOnly=false + rollbackForë¡œ ë®ì–´ì”Œì› ìŠµë‹ˆë‹¤.


---

Controller

// imports
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import javax.validation.constraints.NotBlank;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/process")
public class ProcessController {

    private final ProcessService processService;

    /**
     * ì˜ˆ: /api/process?type=A&model=M1&key=K123
     */
    @GetMapping
    public ResponseEntity<ProcessResult> run(
            @RequestParam @NotBlank String type,
            @RequestParam @NotBlank String model,
            @RequestParam @NotBlank String key
    ) throws Exception {
        ProcessResult result = processService.runAtomic(type, model, key);
        return ResponseEntity.ok(result);
    }
}


---

Service ì¸í„°í˜ì´ìŠ¤

// imports
import javax.validation.constraints.NotBlank;

public interface ProcessService {
    ProcessResult runAtomic(@NotBlank String type, @NotBlank String model, @NotBlank String key) throws Exception;
}


---

Service êµ¬í˜„ì²´ (í´ë˜ìŠ¤ì— @Transactional, ë©”ì„œë“œì—ì„œ ë®ì–´ì“°ê¸°)

// imports
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true) // ê¸°ë³¸ì€ ì½ê¸° ì „ìš©
public class ProcessServiceImpl implements ProcessService {

    private final WorkMapper workMapper;
    private final RefMapper refMapper;
    private final BackupMapper backupMapper;

    /**
     * 1~10 ë‹¨ê³„ ì›ìƒ· ì²˜ë¦¬. í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨ ì‹œ ì˜ˆì™¸ ë˜ì ¸ ì „ì²´ ë¡¤ë°±.
     *
     * 1) work_t1, work_t2 ì¡°íšŒ: ì¡°ê±´ (type, model)
     * 3) ref_t1, ref_t2 ì¡°íšŒ: ì¡°ê±´ (key)
     * 5) work_t1, work_t2 ì‚­ì œ: ì¡°ê±´ (type, model)
     * 7) ref ê²°ê³¼ë¥¼ work í…Œì´ë¸”ì— ì‚½ì…
     * 9) step2ì˜ ì›ë³¸(work ì¡°íšŒ ê²°ê³¼)ì„ backup í…Œì´ë¸”ì— ì‚½ì…
     */
    @Override
    @Transactional(readOnly = false, rollbackFor = Exception.class)
    public ProcessResult runAtomic(String type, String model, String key) throws Exception {
        // 1. work 2í…Œì´ë¸” ì¡°íšŒ (type, model)
        List<WorkRow> w1 = workMapper.selectWorkT1ByTypeModel(type, model);
        List<WorkRow> w2 = workMapper.selectWorkT2ByTypeModel(type, model);

        // 2. ì¡°íšŒ ê²°ê³¼ ê²€ì¦
        if ((w1 == null || w1.isEmpty()) && (w2 == null || w2.isEmpty())) {
            throw new IllegalStateException("[work] type=" + type + ", model=" + model + " ë°ì´í„° ì—†ìŒ");
        }

        // 3. ref 2í…Œì´ë¸” ì¡°íšŒ (key)
        List<RefRow> r1 = refMapper.selectRefT1ByKey(key);
        List<RefRow> r2 = refMapper.selectRefT2ByKey(key);

        // 4. ref ê²°ê³¼ ê²€ì¦
        if ((r1 == null || r1.isEmpty()) && (r2 == null || r2.isEmpty())) {
            throw new IllegalStateException("[ref] key=" + key + " ë°ì´í„° ì—†ìŒ");
        }

        // 5. work ë°ì´í„° ì‚­ì œ (type, model)
        int del1 = (w1 == null || w1.isEmpty()) ? 0 : workMapper.deleteWorkT1ByTypeModel(type, model);
        int del2 = (w2 == null || w2.isEmpty()) ? 0 : workMapper.deleteWorkT2ByTypeModel(type, model);

        // 6. ì‚­ì œ ê²°ê³¼ ê²€ì¦
        if ((w1 != null && !w1.isEmpty() && del1 <= 0) ||
            (w2 != null && !w2.isEmpty() && del2 <= 0)) {
            throw new IllegalStateException("[work] ì‚­ì œ ê²°ê³¼ ë¹„ì •ìƒ");
        }

        // 7. ref ê²°ê³¼ë¥¼ work í…Œì´ë¸”ì— ì‚½ì… (ëª¨ë¸/íƒ€ì… ë§¤í•‘)
        int ins1 = 0;
        for (RefRow row : r1) ins1 += workMapper.insertIntoWorkT1(fromRefToWork(row, type, model));
        int ins2 = 0;
        for (RefRow row : r2) ins2 += workMapper.insertIntoWorkT2(fromRefToWork(row, type, model));

        // 8. ì‚½ì… ê²°ê³¼ ê²€ì¦
        if (ins1 < r1.size() || ins2 < r2.size()) {
            throw new IllegalStateException("[work] ì‚½ì… ê±´ìˆ˜ ë¶€ì¡±");
        }

        // 9. ë°±ì—… í…Œì´ë¸”ì— ì›ë³¸(w1, w2) ì‚½ì…
        int bak1 = 0; for (WorkRow row : w1) bak1 += backupMapper.insertBackupT1(row);
        int bak2 = 0; for (WorkRow row : w2) bak2 += backupMapper.insertBackupT2(row);

        // 10. ë°±ì—… ê²°ê³¼ ê²€ì¦
        if (bak1 < w1.size() || bak2 < w2.size()) {
            throw new IllegalStateException("[backup] ì‚½ì… ê±´ìˆ˜ ë¶€ì¡±");
        }

        // ì •ìƒ ì™„ë£Œ â†’ ì»¤ë°‹
        return ProcessResult.of(del1, del2, ins1, ins2, bak1, bak2, r1.size(), r2.size());
    }

    /** ref_* â†’ work_* ë§¤í•‘: ìŠ¤í‚¤ë§ˆì— ë§ê²Œ ìˆ˜ì •í•˜ì„¸ìš”. */
    private WorkRow fromRefToWork(RefRow ref, String type, String model) {
        WorkRow w = new WorkRow();
        w.setType(type);
        w.setModel(model);
        w.setColA(ref.getColA());
        w.setColB(ref.getColB());
        // í•„ìš”í•œ í•„ë“œ ì¶”ê°€ ë§¤í•‘
        return w;
    }
}


---

ê²°ê³¼ DTO

// imports
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ProcessResult {
    private int deletedWorkT1;
    private int deletedWorkT2;
    private int insertedWorkT1;
    private int insertedWorkT2;
    private int backupT1;
    private int backupT2;
    private int refT1Count;
    private int refT2Count;

    public static ProcessResult of(int d1, int d2, int i1, int i2, int b1, int b2, int c1, int c2) {
        return new ProcessResult(d1, d2, i1, i2, b1, b2, c1, c2);
    }
}


---

MyBatis Mapper (ì¸í„°í˜ì´ìŠ¤)

// imports
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import java.util.List;

@Mapper
public interface WorkMapper {
    List<WorkRow> selectWorkT1ByTypeModel(@Param("type") String type, @Param("model") String model);
    List<WorkRow> selectWorkT2ByTypeModel(@Param("type") String type, @Param("model") String model);

    int deleteWorkT1ByTypeModel(@Param("type") String type, @Param("model") String model);
    int deleteWorkT2ByTypeModel(@Param("type") String type, @Param("model") String model);

    int insertIntoWorkT1(@Param("row") WorkRow row);
    int insertIntoWorkT2(@Param("row") WorkRow row);
}

@Mapper
public interface RefMapper {
    List<RefRow> selectRefT1ByKey(@Param("key") String key);
    List<RefRow> selectRefT2ByKey(@Param("key") String key);
}

@Mapper
public interface BackupMapper {
    int insertBackupT1(@Param("row") WorkRow row);
    int insertBackupT2(@Param("row") WorkRow row);
}


---

(ì„ íƒ) MyBatis XML ìŠ¤ë‹ˆí«

<!-- WorkMapper.xml -->
<select id="selectWorkT1ByTypeModel" resultType="WorkRow">
  SELECT type, model, col_a AS colA, col_b AS colB
  FROM work_t1
  WHERE type = #{type}
    AND model = #{model}
</select>

<select id="selectWorkT2ByTypeModel" resultType="WorkRow">
  SELECT type, model, col_a AS colA, col_b AS colB
  FROM work_t2
  WHERE type = #{type}
    AND model = #{model}
</select>

<delete id="deleteWorkT1ByTypeModel">
  DELETE FROM work_t1 WHERE type = #{type} AND model = #{model}
</delete>

<delete id="deleteWorkT2ByTypeModel">
  DELETE FROM work_t2 WHERE type = #{type} AND model = #{model}
</delete>

<insert id="insertIntoWorkT1">
  INSERT INTO work_t1 (type, model, col_a, col_b)
  VALUES (#{row.type}, #{row.model}, #{row.colA}, #{row.colB})
</insert>

<insert id="insertIntoWorkT2">
  INSERT INTO work_t2 (type, model, col_a, col_b)
  VALUES (#{row.type}, #{row.model}, #{row.colA}, #{row.colB})
</insert>

<!-- RefMapper.xml -->
<select id="selectRefT1ByKey" resultType="RefRow">
  SELECT key, col_a AS colA, col_b AS colB
  FROM ref_t1
  WHERE key = #{key}
</select>

<select id="selectRefT2ByKey" resultType="RefRow">
  SELECT key, col_a AS colA, col_b AS colB
  FROM ref_t2
  WHERE key = #{key}
</select>

<!-- BackupMapper.xml -->
<insert id="insertBackupT1">
  INSERT INTO backup_t1 (type, model, col_a, col_b)
  VALUES (#{row.type}, #{row.model}, #{row.colA}, #{row.colB})
</insert>

<insert id="insertBackupT2">
  INSERT INTO backup_t2 (type, model, col_a, col_b)
  VALUES (#{row.type}, #{row.model}, #{row.colA}, #{row.colB})
</insert>


---

ì—”í‹°í‹°(ì˜ˆì‹œ)

// imports
import lombok.Data;

@Data
public class WorkRow {
    private String type;
    private String model;
    private String colA;
    private String colB;
    // ...
}

@Data
public class RefRow {
    private String key;
    private String colA;
    private String colB;
    // ...
}


---

ìš´ìš© íŒ (ì§§ê²Œ)

ì˜ˆì™¸ë¥¼ ë˜ì ¸ì•¼ ë¡¤ë°±ë©ë‹ˆë‹¤. (ì²´í¬ ì˜ˆì™¸ê¹Œì§€ í¬í•¨í•˜ë ¤ë©´ ë©”ì„œë“œì— rollbackFor = Exception.class)

ì œì•½ ì¶©ëŒì´ ìš°ë ¤ë˜ë©´ 7ë‹¨ê³„ INSERTì— PostgreSQL/Greenplumì˜ ON CONFLICT ì „ëµ ì ìš© ê²€í† .

ëŒ€ëŸ‰ ë°ì´í„°ë©´ í•œ íŠ¸ëœì­ì…˜ì´ ê¸¸ì–´ì§€ì§€ ì•Šë„ë¡ ì²­í¬(batch)ë¡œ ë‚˜ëˆ„ëŠ” ê²ƒë„ ë°©ë²•ì…ë‹ˆë‹¤.


í•„ìš”í•˜ë©´ í…Œì´ë¸”/ì»¬ëŸ¼ ì‹¤ëª… ì£¼ì‹œë©´ ìœ„ XMLì„ ì‹¤í–‰ ê°€ëŠ¥í•œ ìˆ˜ì¤€ìœ¼ë¡œ ë”± ë§ê²Œ ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆí•´ì„œ ë“œë¦´ê²Œìš”.
ëŠ˜ì²˜ëŸ¼ ê¹”ë”í•˜ê²Œ ê°‘ì‹œë‹¤, ì§€ìš°ë‹˜! ğŸ™Œ

