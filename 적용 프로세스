 구조가 Service 인터페이스 + ServiceImpl 구현체이고, **서비스 클래스(구현체)에 @Transactional**이 붙어있는 상황을 기준으로, 요청하신 1→10 단계를 원샷 트랜잭션으로 처리하는 예시를 드립니다.
(핵심: 클래스 레벨은 기본값으로 두고, 실제 작업 메서드에서만 readOnly=false + rollbackFor로 덮어쓰기)


---

Service 인터페이스

// imports
import javax.validation.constraints.NotBlank;

public interface ProcessService {
    ProcessResult runAtomic(@NotBlank String model, @NotBlank String key) throws Exception;
}


---

Service 구현체 (클래스에 @Transactional 존재)

// imports
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true) // 클래스 기본값: 읽기 전용(권장)
public class ProcessServiceImpl implements ProcessService {

    private final WorkMapper workMapper;
    private final RefMapper refMapper;
    private final BackupMapper backupMapper;

    /**
     * 1~10단계를 하나의 트랜잭션으로 처리.
     * 하나라도 실패 시 예외 발생 → 전체 롤백.
     */
    @Override
    @Transactional(readOnly = false, rollbackFor = Exception.class) // 메서드에서 덮어쓰기
    public ProcessResult runAtomic(String model, String key) throws Exception {
        // 1) work 테이블 2곳에서 model 조건 조회
        List<WorkRow> w1 = workMapper.selectWorkT1ByModel(model);
        List<WorkRow> w2 = workMapper.selectWorkT2ByModel(model);

        // 2) 조회 결과 검증
        if ((w1 == null || w1.isEmpty()) && (w2 == null || w2.isEmpty())) {
            throw new IllegalStateException("work_t1/work_t2: model=" + model + " 데이터 없음");
        }

        // 3) ref 테이블 2곳에서 key 조건 조회
        List<RefRow> r1 = refMapper.selectRefT1ByKey(key);
        List<RefRow> r2 = refMapper.selectRefT2ByKey(key);

        // 4) ref 결과 검증
        if ((r1 == null || r1.isEmpty()) && (r2 == null || r2.isEmpty())) {
            throw new IllegalStateException("ref_t1/ref_t2: key=" + key + " 데이터 없음");
        }

        // 5) work에서 model로 조회됐던 데이터 삭제
        int del1 = (w1 == null || w1.isEmpty()) ? 0 : workMapper.deleteWorkT1ByModel(model);
        int del2 = (w2 == null || w2.isEmpty()) ? 0 : workMapper.deleteWorkT2ByModel(model);

        // 6) 삭제 결과 검증(있던 건이 있었으면 최소 1건 이상 삭제돼야 함)
        if ((w1 != null && !w1.isEmpty() && del1 <= 0) ||
            (w2 != null && !w2.isEmpty() && del2 <= 0)) {
            throw new IllegalStateException("work_t1/work_t2 삭제 결과 비정상");
        }

        // 7) ref 값(r1,r2)을 model로 매핑하여 work 테이블에 삽입
        int ins1 = 0;
        for (RefRow row : r1) ins1 += workMapper.insertIntoWorkT1(fromRefToWork(row, model));
        int ins2 = 0;
        for (RefRow row : r2) ins2 += workMapper.insertIntoWorkT2(fromRefToWork(row, model));

        // 8) 삽입 결과 검증
        if (ins1 < r1.size() || ins2 < r2.size()) {
            throw new IllegalStateException("work_t1/work_t2 삽입 건수 부족");
        }

        // 9) 백업 테이블(2곳)에 step 2의 원본(work 조회 결과 w1,w2) 삽입
        int bak1 = 0; for (WorkRow row : w1) bak1 += backupMapper.insertBackupT1(row);
        int bak2 = 0; for (WorkRow row : w2) bak2 += backupMapper.insertBackupT2(row);

        // 10) 백업 결과 검증
        if (bak1 < w1.size() || bak2 < w2.size()) {
            throw new IllegalStateException("backup_t1/backup_t2 삽입 건수 부족");
        }

        // 모두 성공하면 커밋
        return ProcessResult.of(del1, del2, ins1, ins2, bak1, bak2, r1.size(), r2.size());
    }

    /** ref_* → work_* 매핑 (스키마에 맞게 수정) */
    private WorkRow fromRefToWork(RefRow ref, String model) {
        WorkRow w = new WorkRow();
        w.setModel(model);
        w.setColA(ref.getColA());
        w.setColB(ref.getColB());
        // ...필요 필드 매핑
        return w;
    }
}

> 포인트:

클래스 레벨에 @Transactional(readOnly = true)로 기본을 안전하게 두고, 쓰기/삭제가 있는 메서드만 readOnly = false로 덮어쓰기.

rollbackFor = Exception.class로 체크 예외 포함 전체 롤백 보장.

위 메서드는 단일 메서드 내에서 모든 단계를 수행하므로 self-invocation 문제 없음.





---

Controller (요청 진입점)

// imports
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/process")
public class ProcessController {
    private final ProcessService processService;

    @GetMapping
    public ResponseEntity<ProcessResult> run(
            @RequestParam String model,
            @RequestParam String key
    ) throws Exception {
        return ResponseEntity.ok(processService.runAtomic(model, key));
    }
}


---

결과 DTO

// imports
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ProcessResult {
    private int deletedWorkT1;
    private int deletedWorkT2;
    private int insertedWorkT1;
    private int insertedWorkT2;
    private int backupT1;
    private int backupT2;
    private int refT1Count;
    private int refT2Count;

    public static ProcessResult of(int d1, int d2, int i1, int i2, int b1, int b2, int c1, int c2) {
        return new ProcessResult(d1, d2, i1, i2, b1, b2, c1, c2);
    }
}


---

MyBatis Mapper (인터페이스)

// imports
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import java.util.List;

@Mapper
public interface WorkMapper {
    List<WorkRow> selectWorkT1ByModel(@Param("model") String model);
    List<WorkRow> selectWorkT2ByModel(@Param("model") String model);

    int deleteWorkT1ByModel(@Param("model") String model);
    int deleteWorkT2ByModel(@Param("model") String model);

    int insertIntoWorkT1(@Param("row") WorkRow row);
    int insertIntoWorkT2(@Param("row") WorkRow row);
}

@Mapper
public interface RefMapper {
    List<RefRow> selectRefT1ByKey(@Param("key") String key);
    List<RefRow> selectRefT2ByKey(@Param("key") String key);
}

@Mapper
public interface BackupMapper {
    int insertBackupT1(@Param("row") WorkRow row);
    int insertBackupT2(@Param("row") WorkRow row);
}


---

(선택) MyBatis XML 샘플 스니펫

<!-- WorkMapper.xml -->
<select id="selectWorkT1ByModel" resultType="WorkRow">
  SELECT model, col_a AS colA, col_b AS colB
  FROM work_t1
  WHERE model = #{model}
</select>

<delete id="deleteWorkT1ByModel">
  DELETE FROM work_t1 WHERE model = #{model}
</delete>

<insert id="insertIntoWorkT1">
  INSERT INTO work_t1 (model, col_a, col_b)
  VALUES (#{row.model}, #{row.colA}, #{row.colB})
</insert>

> work_t2, ref_t1/ref_t2, backup_t1/backup_t2도 동일 패턴으로 작성하시면 됩니다.
대량 삽입이면 foreach(batch) 또는 Greenplum 대량처리 전략(COPY 등)을 검토하세요.




---

체크리스트 (꼭 보면 좋은 포인트)

예외를 던져야 롤백: 위 예시는 유효성 실패 시 IllegalStateException을 던져 전체 롤백합니다.

인터페이스가 아닌 구현체에 @Transactional: 프록시 전략(JDK 다이내믹 프록시)일 경우 인터페이스의 어노테이션은 무시될 수 있어, 구현 클래스에 다는 게 안전합니다.

제약조건 충돌 대비: 7·9단계에서 UNIQUE/FOREIGN KEY 충돌 가능성 있으면, 사전 체크나 ON CONFLICT(PostgreSQL/Greenplum) 전략 고려.

성능/락: 데이터가 많다면 한 트랜잭션이 너무 길어지지 않게 청크(batch) 처리도 고려.



---

필요하시면 실제 테이블/컬럼명 보내주시면, 매퍼 XML까지 실사용 버전으로 정리해서 드릴게요.
항상 꼼꼼하게, 우리 둘 다 에러는 DB로 돌려보내고(=롤백 😉) 결과는 깨끗하게 커밋합시다!

