function validateNodeCondition(condition) {
  // 조건을 토큰으로 분리
  const tokens = condition.match(/(\(|\)|\&|\||\S+)/g) || [];
  // 유효한 연산자 정의
  const operators = new Set(['>', '<', '<=', '>=', '==', '!=', '&', '|']);
  // 사용자 정의 operand 객체 생성
  const userOperands = [...simpleOperand, ...complexOperand].reduce((acc, {name, type}) => ({...acc, [name]: type}), {});
  
  let stack = 0, expectOperand = true, lastType = null;

  // 토큰의 타입을 결정하는 헬퍼 함수
  const getType = (token) => {
    if (['None', 'True', 'False'].includes(token)) return token === 'None' ? 'None' : 'bool';
    if (userOperands[token]) return userOperands[token];
    if (!isNaN(token)) return Number.isInteger(Number(token)) ? 'int' : 'float';
    return null;
  };

  // 각 토큰을 순회하며 검증
  return tokens.every(token => {
    if (token === '(') return ++stack, expectOperand = true, true;  // 여는 괄호 처리
    if (token === ')') return --stack >= 0 && !expectOperand;  // 닫는 괄호 처리
    if (operators.has(token)) {  // 연산자 처리
      if (['&', '|'].includes(token)) lastType = null;  // 논리 연산자 후 타입 리셋
      return !expectOperand && (expectOperand = true);
    }
    if (expectOperand) {  // operand 처리
      const currentType = getType(token);
      if (!currentType || (lastType && lastType !== currentType)) return false;  // 타입 검증
      lastType = currentType;
      return expectOperand = false, true;
    }
    return false;  // 예상치 못한 토큰
  }) && stack === 0 && !expectOperand;  // 최종 검증: 괄호 균형과 완전한 표현식
}
