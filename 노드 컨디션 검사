function validateNodeCondition(nodes) {
  // 유효한 연산자 정의
  const operators = new Set(['>', '<', '<=', '>=', '==', '!=', '&', '|']);
  // 사용자 정의 operand 객체 생성
  const userOperands = [...simpleOperand, ...complexOperand].reduce((acc, {name, type}) => ({...acc, [name]: type}), {});

  // 토큰의 타입을 결정하는 헬퍼 함수
  const getType = (token) => {
    if (['None', 'True', 'False'].includes(token)) return token === 'None' ? 'None' : 'bool';
    if (userOperands[token]) return userOperands[token];
    if (!isNaN(token)) return Number.isInteger(Number(token)) ? 'int' : 'float';
    return null;
  };

  // 단일 노드의 condition을 검증하는 내부 함수
  const validateSingleCondition = (condition, nodeId) => {
    const tokens = condition.match(/(\(|\)|\&|\||\S+)/g) || [];
    let stack = 0, expectOperand = true, lastType = null;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token === '(') {
        stack++;
        expectOperand = true;
      } else if (token === ')') {
        if (--stack < 0 || expectOperand) {
          return `Node ${nodeId}: Invalid parenthesis at position ${i}`;
        }
      } else if (operators.has(token)) {
        if (expectOperand) {
          return `Node ${nodeId}: Unexpected operator '${token}' at position ${i}`;
        }
        if (['&', '|'].includes(token)) lastType = null;
        expectOperand = true;
      } else if (expectOperand) {
        const currentType = getType(token);
        if (!currentType) {
          return `Node ${nodeId}: Invalid operand '${token}' at position ${i}`;
        }
        if (lastType && lastType !== currentType) {
          return `Node ${nodeId}: Type mismatch: expected ${lastType}, got ${currentType} at position ${i}`;
        }
        lastType = currentType;
        expectOperand = false;
      } else {
        return `Node ${nodeId}: Unexpected token '${token}' at position ${i}`;
      }
    }

    if (stack !== 0) {
      return `Node ${nodeId}: Unbalanced parentheses`;
    }
    if (expectOperand) {
      return `Node ${nodeId}: Expression ends with an operator`;
    }

    return null; // 유효한 조건
  };

  // 모든 노드의 condition 검증
  const invalidNodes = nodes
    .map(node => {
      const error = validateSingleCondition(node.nodeCondition, node.id);
      return error ? { id: node.id, error } : null;
    })
    .filter(result => result !== null);

  // 최종 결과 반환
  if (invalidNodes.length > 0) {
    return {
      isValid: false,
      message: "Some nodes have invalid conditions",
      invalidNodes
    };
  }

  return { isValid: true, message: "All node conditions are valid" };
}



ㅡㅡㅡㅡㅡㅡㅡ

function validateNodeCondition(nodes) {
  const operators = new Set(['>', '<', '<=', '>=', '==', '!=', '&', '|']);
  const userOperands = [...simpleOperand, ...complexOperand].reduce((acc, {name, type}) => ({...acc, [name]: type}), {});

  // 토큰의 타입 결정
  const getType = (token) => {
    if (['None', 'True', 'False'].includes(token)) return token === 'None' ? 'None' : 'bool';
    if (userOperands[token]) return userOperands[token];
    return !isNaN(token) ? (Number.isInteger(Number(token)) ? 'int' : 'float') : 'string';
  };

  // 타입 호환성 검사
  const isTypeCompatible = (type1, type2) => 
    type1 === type2 || type1 === 'varius' || type2 === 'varius' || 
    (type1 === 'int' && type2 === 'float') || (type1 === 'float' && type2 === 'int');

  const validateSingleCondition = (condition, nodeId) => {
    const tokens = condition.match(/(\(|\)|&|\||\S+)/g) || [];
    let stack = 0, expectOperand = true, lastType = null;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token === '(') {
        stack++; expectOperand = true;
      } else if (token === ')') {
        if (--stack < 0 || expectOperand) return `Node ${nodeId}: Invalid parenthesis at position ${i}`; // 노드 ${nodeId}: ${i}번째 위치에 잘못된 괄호
      } else if (operators.has(token)) {
        if (expectOperand) return `Node ${nodeId}: Unexpected operator '${token}' at position ${i}`; // 노드 ${nodeId}: ${i}번째 위치에 예상치 못한 연산자 '${token}'
        expectOperand = true;
        if (['&', '|'].includes(token)) lastType = null;
      } else if (expectOperand) {
        const currentType = getType(token);
        if (lastType && !isTypeCompatible(lastType, currentType)) 
          return `Node ${nodeId}: Type mismatch: ${lastType} is not compatible with ${currentType} at position ${i}`; // 노드 ${nodeId}: 타입 불일치: ${i}번째 위치에서 ${lastType}과 ${currentType}이 호환되지 않음
        lastType = currentType;
        expectOperand = false;
      } else {
        return `Node ${nodeId}: Unexpected token '${token}' at position ${i}`; // 노드 ${nodeId}: ${i}번째 위치에 예상치 못한 토큰 '${token}'
      }
    }

    if (stack !== 0) return `Node ${nodeId}: Unbalanced parentheses`; // 노드 ${nodeId}: 괄호가 균형잡히지 않음
    if (expectOperand) return `Node ${nodeId}: Expression ends with an operator`; // 노드 ${nodeId}: 표현식이 연산자로 끝남

    return null; // 유효한 조건
  };

  // 모든 노드의 condition 검증
  const invalidNodes = nodes
    .map(node => {
      const error = validateSingleCondition(node.nodeCondition, node.id);
      return error ? { id: node.id, error } : null;
    })
    .filter(Boolean);

  // 최종 결과 반환
  return invalidNodes.length > 0
    ? { isValid: false, message: "Some nodes have invalid conditions", invalidNodes } // 일부 노드의 조건이 유효하지 않습니다
    : { isValid: true, message: "All node conditions are valid" }; // 모든 노드의 조건이 유효합니다
}





ㅡㅡㅡㅡㅡㅡ

!표로 true, false 표시 추가


function validateNodeCondition(nodes) {
  const operators = new Set(['>', '<', '<=', '>=', '==', '!=', '&', '|', '!']);
  const userOperands = [...simpleOperand, ...complexOperand].reduce((acc, {name, type}) => ({...acc, [name]: type}), {});

  // 토큰의 타입 결정
  const getType = (token) => {
    if (['True', 'False'].includes(token)) return 'bool';
    if (token === 'None') return 'None';
    if (userOperands[token]) return userOperands[token];
    return !isNaN(token) ? (Number.isInteger(Number(token)) ? 'int' : 'float') : 'string';
  };

  // 타입 호환성 검사
  const isTypeCompatible = (type1, type2) => 
    type1 === type2 || type1 === 'varius' || type2 === 'varius' || 
    (type1 === 'int' && type2 === 'float') || (type1 === 'float' && type2 === 'int');

  const validateSingleCondition = (condition, nodeId) => {
    const tokens = condition.match(/(!?[A-Za-z0-9_]+|\(|\)|&|\||\S+)/g) || [];
    let stack = 0, expectOperand = true, lastType = null;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token === '(') {
        stack++; expectOperand = true;
      } else if (token === ')') {
        if (--stack < 0 || expectOperand) return `Node ${nodeId}: Invalid parenthesis at position ${i}`; // 노드 ${nodeId}: ${i}번째 위치에 잘못된 괄호
      } else if (operators.has(token)) {
        if (expectOperand && token !== '!') return `Node ${nodeId}: Unexpected operator '${token}' at position ${i}`; // 노드 ${nodeId}: ${i}번째 위치에 예상치 못한 연산자 '${token}'
        expectOperand = token !== '!';
        if (['&', '|'].includes(token)) lastType = null;
      } else {
        const currentType = getType(token.replace(/^!/, '')); // Remove leading '!' for type checking
        if (currentType === 'bool' && (token === 'True' || token === 'False' || token.startsWith('!'))) {
          expectOperand = false;
        } else if (expectOperand) {
          if (lastType && !isTypeCompatible(lastType, currentType)) 
            return `Node ${nodeId}: Type mismatch: ${lastType} is not compatible with ${currentType} at position ${i}`; // 노드 ${nodeId}: 타입 불일치: ${i}번째 위치에서 ${lastType}과 ${currentType}이 호환되지 않음
          expectOperand = false;
        } else {
          return `Node ${nodeId}: Unexpected token '${token}' at position ${i}`; // 노드 ${nodeId}: ${i}번째 위치에 예상치 못한 토큰 '${token}'
        }
        lastType = currentType;
      }
    }

    if (stack !== 0) return `Node ${nodeId}: Unbalanced parentheses`; // 노드 ${nodeId}: 괄호가 균형잡히지 않음
    if (expectOperand) return `Node ${nodeId}: Expression ends with an operator`; // 노드 ${nodeId}: 표현식이 연산자로 끝남

    return null; // 유효한 조건
  };

  // 모든 노드의 condition 검증
  const invalidNodes = nodes
    .map(node => {
      const error = validateSingleCondition(node.nodeCondition, node.id);
      return error ? { id: node.id, error } : null;
    })
    .filter(Boolean);

  // 최종 결과 반환
  return invalidNodes.length > 0
    ? { isValid: false, message: "Some nodes have invalid conditions", invalidNodes } // 일부 노드의 조건이 유효하지 않습니다
    : { isValid: true, message: "All node conditions are valid" }; // 모든 노드의 조건이 유효합니다
}
