function validateNodeCondition(nodes) {
  // 유효한 연산자 정의
  const operators = new Set(['>', '<', '<=', '>=', '==', '!=', '&', '|']);
  // 사용자 정의 operand 객체 생성
  const userOperands = [...simpleOperand, ...complexOperand].reduce((acc, {name, type}) => ({...acc, [name]: type}), {});

  // 토큰의 타입을 결정하는 헬퍼 함수
  const getType = (token) => {
    if (['None', 'True', 'False'].includes(token)) return token === 'None' ? 'None' : 'bool';
    if (userOperands[token]) return userOperands[token];
    if (!isNaN(token)) return Number.isInteger(Number(token)) ? 'int' : 'float';
    return null;
  };

  // 단일 노드의 condition을 검증하는 내부 함수
  const validateSingleCondition = (condition, nodeId) => {
    const tokens = condition.match(/(\(|\)|\&|\||\S+)/g) || [];
    let stack = 0, expectOperand = true, lastType = null;

    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token === '(') {
        stack++;
        expectOperand = true;
      } else if (token === ')') {
        if (--stack < 0 || expectOperand) {
          return `Node ${nodeId}: Invalid parenthesis at position ${i}`;
        }
      } else if (operators.has(token)) {
        if (expectOperand) {
          return `Node ${nodeId}: Unexpected operator '${token}' at position ${i}`;
        }
        if (['&', '|'].includes(token)) lastType = null;
        expectOperand = true;
      } else if (expectOperand) {
        const currentType = getType(token);
        if (!currentType) {
          return `Node ${nodeId}: Invalid operand '${token}' at position ${i}`;
        }
        if (lastType && lastType !== currentType) {
          return `Node ${nodeId}: Type mismatch: expected ${lastType}, got ${currentType} at position ${i}`;
        }
        lastType = currentType;
        expectOperand = false;
      } else {
        return `Node ${nodeId}: Unexpected token '${token}' at position ${i}`;
      }
    }

    if (stack !== 0) {
      return `Node ${nodeId}: Unbalanced parentheses`;
    }
    if (expectOperand) {
      return `Node ${nodeId}: Expression ends with an operator`;
    }

    return null; // 유효한 조건
  };

  // 모든 노드의 condition 검증
  const invalidNodes = nodes
    .map(node => {
      const error = validateSingleCondition(node.nodeCondition, node.id);
      return error ? { id: node.id, error } : null;
    })
    .filter(result => result !== null);

  // 최종 결과 반환
  if (invalidNodes.length > 0) {
    return {
      isValid: false,
      message: "Some nodes have invalid conditions",
      invalidNodes
    };
  }

  return { isValid: true, message: "All node conditions are valid" };
}
