
WITH base AS (
  SELECT
    dt::date AS d,
    eqp_id,
    name,
    sec::numeric AS sec_num,
    split_part(name, '_', 1) AS name_core  -- 예: Monday_ddd → Monday
  FROM metrics
),
norm AS (
  SELECT
    d,
    eqp_id,
    sec_num,
    CASE
      WHEN name_core IN ('Daily', 'Weekly') THEN name_core
      WHEN name_core IN ('Monday','Tuesday','Wednesday','Thursday',
                         'Friday','Saturday','Sunday') THEN 'Weekday'
    END AS kind,
    CASE
      WHEN name_core IN ('Monday','Tuesday','Wednesday','Thursday',
                         'Friday','Saturday','Sunday') THEN name_core
    END AS weekday_label
  FROM base
),
agg AS (
  SELECT
    d,
    eqp_id,
    COUNT(*) AS total_cnt,
    COALESCE(SUM(sec_num), 0) AS total_sec,

    COUNT(*) FILTER (WHERE kind = 'Daily') AS daily_cnt,
    COALESCE(SUM(sec_num) FILTER (WHERE kind = 'Daily'), 0) AS daily_sec,

    COUNT(*) FILTER (WHERE kind = 'Weekday') AS day_cnt,
    COALESCE(SUM(sec_num) FILTER (WHERE kind = 'Weekday'), 0) AS day_sec,

    COUNT(*) FILTER (WHERE kind = 'Weekly') AS weekly_cnt,
    COALESCE(SUM(sec_num) FILTER (WHERE kind = 'Weekly'), 0) AS weekly_sec,

    MAX(weekday_label) FILTER (WHERE kind = 'Weekday') AS d_of_w
  FROM norm
  GROUP BY d, eqp_id
)
SELECT
  a.d AS "date",
  a.d_of_w AS "d-of-w",
  a.daily_cnt AS "daily cnt",
  ROUND(a.daily_sec, 3) AS "daily sec",
  a.day_cnt AS "day cnt",
  ROUND(a.day_sec, 3) AS "day sec",
  a.weekly_cnt AS "weekly cnt",
  ROUND(a.weekly_sec, 3) AS "weekly sec",
  a.total_cnt AS "total cnt",
  ROUND(a.total_sec, 3) AS "total sec"
FROM agg a
ORDER BY a.d, a.eqp_id;








Java: 행→피벗(JSON) — 계산 없음, 그룹핑만
코드 복사
Java
// imports
import java.time.LocalDate;
import java.math.BigDecimal;
import java.util.*;

// 쿼리 결과를 받는 DTO (이미 쓰시는 resultMap 그대로)
public class RowEntity {
  private LocalDate date;
  private String dOfW;
  private String eqpId;
  private Integer dailyCnt;
  private BigDecimal dailySec;
  private Integer dayCnt;
  private BigDecimal daySec;
  private Integer weeklyCnt;
  private BigDecimal weeklySec;
  private Integer totalCnt;
  private BigDecimal totalSec;
  // getter/setter...
}

public class PivotBuilder {

  @SuppressWarnings("unchecked")
  public static List<Map<String, Object>> toPivot(List<RowEntity> rows) {
    // 날짜 순서 유지
    Map<LocalDate, Map<String, Object>> byDate = new LinkedHashMap<>();

    for (RowEntity r : rows) {
      // 날짜별 1행 생성
      Map<String, Object> row = byDate.computeIfAbsent(r.getDate(), d -> {
        Map<String, Object> m = new LinkedHashMap<>();
        m.put("date", d);
        m.put("d_of_w", r.getDOfW());   // 같은 날짜면 동일하다고 가정
        m.put("by_eqp", new TreeMap<String, Map<String, Object>>()); // eqp 정렬 원하면 TreeMap
        return m;
      });

      // by_eqp에 eqp별 메트릭 넣기 (추가 계산 X)
      Map<String, Map<String, Object>> byEqp = (Map<String, Map<String, Object>>) row.get("by_eqp");
      Map<String, Object> metrics = new LinkedHashMap<>(8);
      metrics.put("daily_cnt",  nvl(r.getDailyCnt()));
      metrics.put("daily_sec",  r.getDailySec());
      metrics.put("day_cnt",    nvl(r.getDayCnt()));
      metrics.put("day_sec",    r.getDaySec());
      metrics.put("weekly_cnt", nvl(r.getWeeklyCnt()));
      metrics.put("weekly_sec", r.getWeeklySec());
      metrics.put("total_cnt",  nvl(r.getTotalCnt()));
      metrics.put("total_sec",  r.getTotalSec());
      byEqp.put(r.getEqpId(), metrics);
    }

    return new ArrayList<>(byDate.values());
  }

  private static int nvl(Integer v) { return v == null ? 0 : v; }
}
컨트롤러는 그대로:
코드 복사
Java
@GetMapping("/api/metrics/pivot")
public Object getPivot() {
  var rows = mapper.selectMetricsRows(); // 지금 쓰는 쿼리(agg 결과)
  return PivotBuilder.toPivot(rows);     // 계산 없이 피벗만
}
Vue(ag-Grid): 동적 컬럼 (valueGetter만)
코드 복사
Js
// 응답 구조: { date, d_of_w, by_eqp: { eqp01:{daily_cnt,...}, eqp02:{...} } }
const eqpSet = new Set()
for (const r of rows) for (const k of Object.keys(r.by_eqp||{})) eqpSet.add(k)
const eqpList = Array.from(eqpSet).sort()

const metricKeys = [
  'daily_cnt','daily_sec',
  'day_cnt','day_sec',
  'weekly_cnt','weekly_sec',
  'total_cnt','total_sec'
]

const columnDefs = [
  { headerName: 'date', field: 'date', pinned: 'left' },
  { headerName: 'd_of_w', field: 'd_of_w', pinned: 'left' },
  ...eqpList.map(eqp => ({
    headerName: eqp, marryChildren: true,
    children: metricKeys.map(m => ({
      headerName: m.replace('_',' '),
      colId: `${eqp}.${m}`,
      valueGetter: p => p.data?.by_eqp?.[eqp]?.[m] ?? null
    }))
  }))
]