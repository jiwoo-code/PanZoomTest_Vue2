

코어 로직을 전부 함수화해서 재활용·가독성을 높였습니다.

<template>
  <div class="popup">
    <!-- 👉 전체 저장 버튼 -->
    <sp-button
      small
      :disabled="!hasDirty"
      @click="saveAll"
      class="save-all-btn"
    >
      저장
    </sp-button>

    <!-- 👉 ag-Grid -->
    <ag-grid-vue
      class="ag-theme-balham"
      style="height:420px"
      :rowData="rowData"
      :columnDefs="columnDefs"
      :gridOptions="gridOptions"
      @grid-ready="onGridReady"
    />
  </div>
</template>

<script>
import axios from '@/plugins/axios';      // 프로젝트 axios 인스턴스

export default {
  /* 상위에서 권한 플래그만 내려줍니다. */
  props: { canEditRemark: Boolean },

  data() {
    return {
      gridApi  : null,
      hasDirty : false,                 // 저장 버튼 on/off
      rowData  : [],                    // (상위에서 fetch 후 props로 받아도 무방)

      /* ✅ 컬럼 정의 */
      columnDefs: [
        { field:'id', headerName:'ID', width:80 },

        { field:'remark',
          headerName:'비고',
          editable : () => this.canEditRemark,          // 권한 체크
          cellEditor: 'agLargeTextCellEditor',
          cellEditorParams:{ cols:28, rows:3 },

          /* 변경된 셀 배경 표시 */
          cellClassRules: {
            'cell-dirty': params => !!params.data.dirty
          }
        }
      ],

      /* ✅ grid 옵션 – onCellValueChanged 에서 더티 표시 */
      gridOptions: {
        defaultColDef: { resizable:true, sortable:true },
        onCellValueChanged: p => this.handleEdit(p)
      }
    };
  },

  /* methods ---------------------------------------------------- */
  methods: {
    onGridReady(p) { this.gridApi = p.api; },

    /* ① 셀 편집 → dirty 플래그 부여 + 저장버튼 활성 */
    handleEdit(p) {
      if (p.colDef.field === 'remark' && this.canEditRemark) {
        p.data.dirty = true;                     // 행 플래그
        this.hasDirty = true;
        // 해당 셀만 다시 렌더 (색상 반영)
        p.api.refreshCells({ rowNodes:[p.node], columns:['remark'] });
      }
    },

    /* ② 더티 행 모으기 */
    collectDirtyRows() {
      const list = [];
      this.gridApi.forEachNode(n => {
        if (n.data.dirty) list.push({ id:n.data.id, remark:n.data.remark });
      });
      return list;
    },

    /* ③ 저장 버튼 */
    async saveAll() {
      const payload = this.collectDirtyRows();
      if (!payload.length) return;

      try {
        await axios.post('/api/history/remark/updateBatch', payload);
        this.markClean();                 // 성공 후 초기화
        this.$toast.success('저장 완료');
      } catch (e) {
        console.error(e);
        this.$toast.error('저장 실패');
      }
    },

    /* ④ 성공 시 더티 플래그·하이라이트 제거 */
    markClean() {
      this.gridApi.forEachNode(n => {
        if (n.data.dirty) {
          n.data.dirty = false;
        }
      });
      this.hasDirty = false;
      this.gridApi.refreshCells({ force: true }); // 모든 셀 재랜더 → 색상 삭제
    }
  }
};
</script>

<style scoped>
.history-popup {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.save-all-btn {
  align-self: flex-end;
}

.cell-dirty {
  background-color: #fff5cc !important;   /* 연노랑 하이라이트 */
}
</style>

동작 요약

1. 비고(remark) 컬럼은 canEditRemark 가 true 일 때만 수정 가능.


2. 사용자가 편집하면 handleEdit() 이 행에 dirty=true 를 심고 저장 버튼 활성.


3. 저장 → collectDirtyRows() 로 더티 행만 payload 로 전송.


4. 성공 시 markClean() 으로 플래그 지우고 셀 하이라이트 제거.



> 모든 로직을 함수화(handleEdit · collectDirtyRows · markClean) 했기 때문에
추후 다른 팝업/페이지에서도 그대로 가져다 사용할 수 있습니다.



ㅡㅡㅡㅡㅡㅡ


<template>
  <div class="grid-container">
    <div class="ag-theme-alpine" style="height: 400px; width: 100%;">
      <ag-grid-vue
        ref="agGrid"
        :columnDefs="columnDefs"
        :rowData="rowData"
        :defaultColDef="defaultColDef"
        :suppressRowClickSelection="true"
        @grid-ready="onGridReady"
        @cell-value-changed="onCellValueChanged"
      />
    </div>
    
    <!-- 하단 버튼 -->
    <div class="button-container">
      <button 
        :disabled="!hasChanges" 
        :class="{ 'active': hasChanges }"
        @click="saveChanges"
      >
        변경사항 저장
      </button>
      <button 
        :disabled="!hasChanges"
        @click="resetChanges"
      >
        변경사항 취소
      </button>
    </div>
  </div>
</template>

<script>
import { AgGridVue } from 'ag-grid-vue'

export default {
  name: 'EditableGrid',
  components: {
    AgGridVue
  },
  data() {
    return {
      gridApi: null,
      columnApi: null,
      hasChanges: false,
      originalData: [], // 원본 데이터 저장
      rowData: [
        { id: 1, name: '홍길동', department: '개발팀', remark: '우수 직원' },
        { id: 2, name: '김철수', department: '마케팅팀', remark: '신입 직원' },
        { id: 3, name: '이영희', department: '디자인팀', remark: '창의적' },
        { id: 4, name: '박민수', department: '기획팀', remark: '적극적' },
        { id: 5, name: '정수진', department: '인사팀', remark: '꼼꼼함' }
      ],
      columnDefs: [
        { 
          headerName: 'ID', 
          field: 'id', 
          width: 80,
          editable: false
        },
        { 
          headerName: '이름', 
          field: 'name', 
          width: 120,
          editable: false
        },
        { 
          headerName: '부서', 
          field: 'department', 
          width: 150,
          editable: false
        },
        { 
          headerName: '비고', 
          field: 'remark', 
          width: 200,
          editable: true,
          cellEditor: 'agTextCellEditor',
          cellStyle: { 
            backgroundColor: '#f0f8ff',
            cursor: 'pointer'
          },
          cellEditorParams: {
            maxLength: 100
          }
        }
      ],
      defaultColDef: {
        sortable: true,
        filter: true,
        resizable: true
      }
    }
  },
  mounted() {
    // 원본 데이터 깊은 복사로 저장
    this.originalData = JSON.parse(JSON.stringify(this.rowData))
  },
  methods: {
    onGridReady(params) {
      this.gridApi = params.api
      this.columnApi = params.columnApi
    },
    
    onCellValueChanged(event) {
      // remark 컬럼의 변경사항만 체크
      if (event.colDef.field === 'remark') {
        this.checkForChanges()
      }
    },
    
    checkForChanges() {
      const currentData = []
      this.gridApi.forEachNode(node => {
        currentData.push(node.data)
      })
      
      // 원본 데이터와 현재 데이터의 remark 필드 비교
      let hasRemarkChanges = false
      
      for (let i = 0; i < currentData.length; i++) {
        const current = currentData[i]
        const original = this.originalData.find(item => item.id === current.id)
        
        if (original && current.remark !== original.remark) {
          hasRemarkChanges = true
          break
        }
      }
      
      this.hasChanges = hasRemarkChanges
    },
    
    saveChanges() {
      if (!this.hasChanges) return
      
      // 현재 그리드 데이터를 가져와서 원본 데이터 업데이트
      const currentData = []
      this.gridApi.forEachNode(node => {
        currentData.push({ ...node.data })
      })
      
      // 원본 데이터 업데이트
      this.originalData = JSON.parse(JSON.stringify(currentData))
      this.hasChanges = false
      
      // 실제 서버 저장 로직은 여기에 구현
      console.log('변경사항 저장됨:', currentData)
      alert('변경사항이 저장되었습니다.')
    },
    
    resetChanges() {
      if (!this.hasChanges) return
      
      // 원본 데이터로 복원
      this.rowData = JSON.parse(JSON.stringify(this.originalData))
      this.hasChanges = false
      
      console.log('변경사항 취소됨')
    }
  }
}
</script>

<style scoped>
.grid-container {
  padding: 20px;
}

.button-container {
  margin-top: 20px;
  display: flex;
  gap: 10px;
}

button {
  padding: 10px 20px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background-color: #f8f9fa;
  cursor: pointer;
  transition: all 0.2s;
}

button:disabled {
  background-color: #e9ecef;
  color: #6c757d;
  cursor: not-allowed;
  opacity: 0.6;
}

button:not(:disabled):hover {
  background-color: #e9ecef;
}

button.active {
  background-color: #007bff;
  color: white;
  border-color: #007bff;
}

button.active:hover {
  background-color: #0056b3;
}

/* AG Grid 스타일 커스터마이징 */
:deep(.ag-theme-alpine) {
  --ag-border-color: #ddd;
  --ag-header-background-color: #f8f9fa;
}

/* 편집 가능한 셀 스타일 */
:deep(.ag-cell[col-id="remark"]) {
  position: relative;
}

:deep(.ag-cell[col-id="remark"]:hover) {
  background-color: #e3f2fd !important;
}

:deep(.ag-cell-edit-input) {
  border: 2px solid #007bff;
  border-radius: 4px;
  padding: 4px 8px;
}
</style>